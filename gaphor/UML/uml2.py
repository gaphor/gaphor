# This file is generated by build_uml.py. DO NOT EDIT!

from __future__ import annotations

from typing import Callable
from gaphor.UML.properties import (
    umlproperty,
    association,
    attribute,
    enumeration,
    derived,
    derivedunion,
    redefine,
)
from gaphor.UML.collection import collection

# 18: override Element
from gaphor.UML.element import Element



class NamedElement(Element):
    visibility: umlproperty[str, str]
    name: umlproperty[str, str]
    qualifiedName: property
    clientDependency: umlproperty[Dependency, collection[Dependency]]
    supplierDependency: umlproperty[Dependency, collection[Dependency]]
    namespace: umlproperty["Namespace", "Namespace"]


class PackageableElement(NamedElement):
    visibility: umlproperty[str, str]


class InstanceSpecification(PackageableElement):
    specification: umlproperty[str, str]
    slot: umlproperty[Slot, collection[Slot]]
    classifier: umlproperty[Classifier, collection[Classifier]]
    extended: umlproperty[Element, collection[Element]]


class EnumerationLiteral(InstanceSpecification):
    enumeration: umlproperty["Enumeration", "Enumeration"]


class Relationship(Element):
    relatedElement: umlproperty[Element, collection[Element]]


class DirectedRelationship(Relationship):
    target: umlproperty[Element, collection[Element]]
    source: umlproperty[Element, collection[Element]]


class PackageMerge(DirectedRelationship):
    mergingPackage: umlproperty["Package", "Package"]
    mergedPackage: umlproperty["Package", "Package"]


class Namespace(NamedElement):
    ownedRule: umlproperty[Constraint, collection[Constraint]]
    elementImport: umlproperty[ElementImport, collection[ElementImport]]
    packageImport: umlproperty[PackageImport, collection[PackageImport]]
    ownedMember: umlproperty[NamedElement, collection[NamedElement]]
    member: umlproperty[NamedElement, collection[NamedElement]]
    importedMember: umlproperty[PackageableElement, collection[PackageableElement]]


class Type(PackageableElement):
    package: umlproperty["Package", "Package"]


class RedefinableElement(NamedElement):
    isLeaf: umlproperty[int, int]
    redefinedElement: umlproperty[RedefinableElement, collection[RedefinableElement]]
    redefinitionContext: umlproperty[Classifier, collection[Classifier]]


class Classifier(Namespace, Type, RedefinableElement):
    isAbstract: umlproperty[int, int]
    ownedUseCase: umlproperty[UseCase, collection[UseCase]]
    generalization: umlproperty[Generalization, collection[Generalization]]
    redefinedClassifier: umlproperty[Classifier, collection[Classifier]]
    substitution: umlproperty[Substitution, collection[Substitution]]
    attribute: umlproperty[Property, collection[Property]]
    feature: umlproperty[Feature, collection[Feature]]
    general: property
    inheritedMember: umlproperty[NamedElement, collection[NamedElement]]


class Association(Classifier, Relationship):
    isDerived: umlproperty[int, int]
    memberEnd: umlproperty[Property, collection[Property]]
    ownedEnd: umlproperty[Property, collection[Property]]
    navigableOwnedEnd: umlproperty[Property, collection[Property]]
    endType: umlproperty[Type, collection[Type]]


class Extension(Association):
    isRequired: umlproperty[int, int]
    ownedEnd: umlproperty["ExtensionEnd", "ExtensionEnd"]
    metaclass: property


class Actor(Classifier):
    ownedAttribute: umlproperty[Property, collection[Property]]


class ActivityNode(RedefinableElement):
    outgoing: umlproperty[ActivityEdge, collection[ActivityEdge]]
    incoming: umlproperty[ActivityEdge, collection[ActivityEdge]]
    inGroup: umlproperty[ActivityGroup, collection[ActivityGroup]]
    inPartition: umlproperty[ActivityPartition, collection[ActivityPartition]]
    redefinedElement: umlproperty[ActivityNode, collection[ActivityNode]]


class ControlNode(ActivityNode):
    pass


class MergeNode(ControlNode):
    pass


class Feature(RedefinableElement):
    isStatic: umlproperty[int, int]
    featuringClassifier: umlproperty[Classifier, collection[Classifier]]


class ActivityEdge(RedefinableElement):
    activity: umlproperty["Activity", "Activity"]
    guard: umlproperty[str, str]
    source: umlproperty["ActivityNode", "ActivityNode"]
    target: umlproperty["ActivityNode", "ActivityNode"]
    inGroup: umlproperty[ActivityGroup, collection[ActivityGroup]]
    redefinedElement: umlproperty[ActivityEdge, collection[ActivityEdge]]


class ObjectFlow(ActivityEdge):
    pass


class FinalNode(ControlNode):
    pass


class ActivityFinalNode(FinalNode):
    pass


class CommunicationPath(Association):
    pass


class Dependency(DirectedRelationship, PackageableElement):
    client: umlproperty[NamedElement, collection[NamedElement]]
    supplier: umlproperty[NamedElement, collection[NamedElement]]


class Permission(Dependency):
    pass


class Abstraction(Dependency):
    mapping: umlproperty[str, str]


class Realization(Abstraction):
    realizingClassifier: umlproperty["Classifier", "Classifier"]
    abstraction: umlproperty["Component", "Component"]


class TypedElement(NamedElement):
    type: umlproperty["Type", "Type"]
    typeValue: umlproperty[str, str]


class ObjectNode(TypedElement, ActivityNode):
    ordering: umlproperty[str, str]
    isControlType: umlproperty[int, int]
    upperBound: umlproperty[str, str]
    selection: umlproperty["Behavior", "Behavior"]


class Pin(ObjectNode):
    pass


class Generalization(DirectedRelationship):
    isSubstitutable: umlproperty[int, int]
    general: umlproperty["Classifier", "Classifier"]
    specific: umlproperty["Classifier", "Classifier"]


class BehavioredClassifier(Classifier):
    ownedBehavior: umlproperty[Behavior, collection[Behavior]]
    ownedTrigger: umlproperty[Trigger, collection[Trigger]]
    implementation: umlproperty[Implementation, collection[Implementation]]


class StructuredClassifier(Classifier):
    ownedConnector: umlproperty[Connector, collection[Connector]]
    ownedAttribute: umlproperty[Property, collection[Property]]
    role: umlproperty[ConnectableElement, collection[ConnectableElement]]
    part: property


class EncapsulatedClassifer(StructuredClassifier):
    ownedPort: umlproperty[Port, collection[Port]]


class Class(BehavioredClassifier, EncapsulatedClassifer):
    ownedOperation: umlproperty[Operation, collection[Operation]]
    nestedClassifier: umlproperty[Classifier, collection[Classifier]]
    ownedAttribute: umlproperty[Property, collection[Property]]
    ownedReception: umlproperty[Reception, collection[Reception]]
    extension: property
    superClass: property


class DeploymentTarget(NamedElement):
    deployment: umlproperty[Deployment, collection[Deployment]]


class Node(Class, DeploymentTarget):
    nestedNode: umlproperty[Node, collection[Node]]


class Device(Node):
    pass


class MultiplicityElement(Element):
    isUnique: umlproperty[int, int]
    isOrdered: umlproperty[int, int]
    upperValue: umlproperty[str, str]
    lowerValue: umlproperty[str, str]
    lower: umlproperty[str, str]
    upper: umlproperty[str, str]


class StructuralFeature(MultiplicityElement, TypedElement, Feature):
    isReadOnly: umlproperty[int, int]
    slot: umlproperty[Slot, collection[Slot]]


class UseCase(BehavioredClassifier):
    subject: umlproperty[Classifier, collection[Classifier]]
    extensionPoint: umlproperty[ExtensionPoint, collection[ExtensionPoint]]
    include: umlproperty[Include, collection[Include]]
    extend: umlproperty[Extend, collection[Extend]]
    ownedAttribute: umlproperty[Property, collection[Property]]


class InputPin(Pin):
    pass


class Manifestation(Abstraction):
    pass


class Component(Class):
    isIndirectlyInstantiated: umlproperty[int, int]
    realization: umlproperty[Realization, collection[Realization]]
    required: property
    provided: property
    ownedMember: umlproperty[PackageableElement, collection[PackageableElement]]


class ConnectableElement(TypedElement):
    end: umlproperty[ConnectorEnd, collection[ConnectorEnd]]


class Interface(Classifier, ConnectableElement):
    ownedAttribute: umlproperty[Property, collection[Property]]
    redefinedInterface: umlproperty[Interface, collection[Interface]]
    nestedInterface: umlproperty[Interface, collection[Interface]]
    ownedOperation: umlproperty[Operation, collection[Operation]]
    ownedReception: umlproperty[Reception, collection[Reception]]


class Include(DirectedRelationship):
    addition: umlproperty["UseCase", "UseCase"]
    includingCase: umlproperty["UseCase", "UseCase"]


class PackageImport(DirectedRelationship):
    visibility: umlproperty[str, str]
    importedPackage: umlproperty["Package", "Package"]
    importingNamespace: umlproperty["Namespace", "Namespace"]


class ProfileApplication(PackageImport):
    importedProfile: umlproperty["Profile", "Profile"]


class ExtensionPoint(RedefinableElement):
    useCase: umlproperty["UseCase", "UseCase"]


class Usage(Dependency):
    pass


class ElementImport(DirectedRelationship):
    visibility: umlproperty[str, str]
    alias: umlproperty[str, str]
    importingNamespace: umlproperty["Namespace", "Namespace"]
    importedElement: umlproperty["PackageableElement", "PackageableElement"]


class Property(StructuralFeature, ConnectableElement):
    aggregation: umlproperty[str, str]
    isDerivedUnion: umlproperty[int, int]
    isDerived: umlproperty[int, int]
    isReadOnly: umlproperty[int, int]
    navigability: property
    datatype: umlproperty["DataType", "DataType"]
    subsettedProperty: umlproperty[Property, collection[Property]]
    classifier: umlproperty["Classifier", "Classifier"]
    redefinedProperty: umlproperty[Property, collection[Property]]
    class_: umlproperty["Class", "Class"]
    defaultValue: umlproperty[str, str]
    association: umlproperty["Association", "Association"]
    interface_: umlproperty["Interface", "Interface"]
    owningAssociation: umlproperty["Association", "Association"]
    useCase: umlproperty["UseCase", "UseCase"]
    actor: umlproperty["Actor", "Actor"]
    isComposite: umlproperty[Namespace, Namespace]
    opposite: property


class ExtensionEnd(Property):
    type: umlproperty["Stereotype", "Stereotype"]


class DataType(Classifier):
    ownedAttribute: umlproperty[Property, collection[Property]]
    ownedOperation: umlproperty[Operation, collection[Operation]]


class Enumeration(DataType):
    literal: umlproperty[EnumerationLiteral, collection[EnumerationLiteral]]


class Slot(Element):
    value: umlproperty[str, str]
    owningInstance: umlproperty["InstanceSpecification", "InstanceSpecification"]
    definingFeature: umlproperty["StructuralFeature", "StructuralFeature"]


class ExecutableNode(ActivityNode):
    pass


class InitialNode(ControlNode):
    pass


class Stereotype(Class):
    pass


# 21: override Diagram
from gaphor.UML.diagram import Diagram



class DeployedArtifact(NamedElement):
    pass


class Artifact(Classifier, DeployedArtifact):
    manifestation: umlproperty[Manifestation, collection[Manifestation]]


class ActivityParameterNode(ObjectNode):
    parameter: umlproperty["Parameter", "Parameter"]


class PrimitiveType(DataType):
    pass


class DecisionNode(ControlNode):
    decisionInput: umlproperty["Behavior", "Behavior"]


class Package(Namespace, PackageableElement):
    ownedDiagram: umlproperty[Diagram, collection[Diagram]]
    nestedPackage: umlproperty[Package, collection[Package]]
    package: umlproperty["Package", "Package"]
    ownedClassifier: umlproperty[Type, collection[Type]]
    packageExtension: umlproperty[PackageMerge, collection[PackageMerge]]
    appliedProfile: umlproperty[ProfileApplication, collection[ProfileApplication]]
    ownedMember: umlproperty[PackageableElement, collection[PackageableElement]]


class Profile(Package):
    metamodelReference: umlproperty[PackageImport, collection[PackageImport]]
    ownedStereotype: umlproperty[Stereotype, collection[Stereotype]]
    metaclassReference: umlproperty[ElementImport, collection[ElementImport]]


class Behavior(Class):
    isReentrant: umlproperty[int, int]
    redefinedBehavior: umlproperty[Behavior, collection[Behavior]]
    context: umlproperty["BehavioredClassifier", "BehavioredClassifier"]


class Activity(Behavior):
    body: umlproperty[str, str]
    language: umlproperty[str, str]
    edge: umlproperty[ActivityEdge, collection[ActivityEdge]]
    group: umlproperty[ActivityGroup, collection[ActivityGroup]]
    node: umlproperty[ActivityNode, collection[ActivityNode]]
    action: umlproperty[Action, collection[Action]]


class Implementation(Realization):
    contract: umlproperty["Interface", "Interface"]
    implementatingClassifier: umlproperty["BehavioredClassifier", "BehavioredClassifier"]


class Parameter(TypedElement, MultiplicityElement):
    direction: umlproperty[str, str]
    defaultValue: umlproperty[str, str]
    ownerFormalParam: umlproperty["BehavioralFeature", "BehavioralFeature"]
    ownerReturnParam: umlproperty["BehavioralFeature", "BehavioralFeature"]
    operation: umlproperty["Operation", "Operation"]


# 24: override Presentation
from gaphor.UML.presentation import Presentation



class BehavioralFeature(Feature, Namespace):
    isAbstract: umlproperty[int, int]
    method: umlproperty[Behavior, collection[Behavior]]
    formalParameter: umlproperty[Parameter, collection[Parameter]]
    raisedException: umlproperty[Type, collection[Type]]
    returnResult: umlproperty[Parameter, collection[Parameter]]
    parameter: umlproperty[Parameter, collection[Parameter]]


class Operation(BehavioralFeature):
    isQuery: umlproperty[int, int]
    precondition: umlproperty[Constraint, collection[Constraint]]
    bodyCondition: umlproperty["Constraint", "Constraint"]
    redefinedOperation: umlproperty[Operation, collection[Operation]]
    class_: umlproperty["Class", "Class"]
    datatype: umlproperty["DataType", "DataType"]
    postcondition: umlproperty[Constraint, collection[Constraint]]
    interface_: umlproperty["Interface", "Interface"]
    raisedException: umlproperty[Type, collection[Type]]
    type: umlproperty[DataType, DataType]
    formalParameter: umlproperty[Parameter, collection[Parameter]]


class ControlFlow(ActivityEdge):
    pass


class Substitution(Realization):
    contract: umlproperty["Classifier", "Classifier"]
    substitutingClassifier: umlproperty["Classifier", "Classifier"]


class OutputPin(Pin):
    pass


class ValuePin(InputPin):
    value_: umlproperty[str, str]


class Action(ExecutableNode):
    effect: umlproperty[str, str]
    output: umlproperty[OutputPin, collection[OutputPin]]
    context_: umlproperty["Classifier", "Classifier"]
    input: umlproperty[InputPin, collection[InputPin]]


class Comment(Element):
    body: umlproperty[str, str]
    annotatedElement: umlproperty[Element, collection[Element]]


class ExecutionEnvironment(Node):
    pass


class Extend(DirectedRelationship):
    extendedCase: umlproperty["UseCase", "UseCase"]
    extensionLocation: umlproperty[ExtensionPoint, collection[ExtensionPoint]]
    extension: umlproperty["UseCase", "UseCase"]
    constraint: umlproperty["Constraint", "Constraint"]


class ActivityGroup(Element):
    activity: umlproperty["Activity", "Activity"]
    edgeContents: umlproperty[ActivityEdge, collection[ActivityEdge]]
    nodeContents: umlproperty[ActivityNode, collection[ActivityNode]]
    superGroup: umlproperty["ActivityGroup", "ActivityGroup"]
    subgroup: umlproperty[ActivityGroup, collection[ActivityGroup]]


class Constraint(PackageableElement):
    constrainedElement: umlproperty[Element, collection[Element]]
    specification: umlproperty[str, str]
    owningState: umlproperty["State", "State"]
    context: umlproperty[Namespace, Namespace]


class InteractionFragment(NamedElement):
    enclosingInteraction: umlproperty["Interaction", "Interaction"]
    covered: umlproperty["Lifeline", "Lifeline"]
    generalOrdering: umlproperty[GeneralOrdering, collection[GeneralOrdering]]


class Interaction(Behavior, InteractionFragment):
    fragment: umlproperty[InteractionFragment, collection[InteractionFragment]]
    lifeline: umlproperty[Lifeline, collection[Lifeline]]
    message: umlproperty[Message, collection[Message]]


class ExecutionOccurence(InteractionFragment):
    finish: umlproperty["OccurrenceSpecification", "OccurrenceSpecification"]
    start: umlproperty["OccurrenceSpecification", "OccurrenceSpecification"]
    behavior: umlproperty[Behavior, collection[Behavior]]


class StateInvariant(InteractionFragment):
    invariant: umlproperty["Constraint", "Constraint"]


class Lifeline(NamedElement):
    coveredBy: umlproperty[InteractionFragment, collection[InteractionFragment]]
    interaction: umlproperty["Interaction", "Interaction"]
    discriminator: umlproperty[str, str]
    parse: Callable[[Lifeline, str], None]
    render: Callable[[Lifeline], str]


class Message(NamedElement):
    messageKind: property
    messageSort: umlproperty[str, str]
    argument: umlproperty[str, str]
    signature: umlproperty["NamedElement", "NamedElement"]
    sendEvent: umlproperty["MessageEnd", "MessageEnd"]
    receiveEvent: umlproperty["MessageEnd", "MessageEnd"]
    interaction: umlproperty["Interaction", "Interaction"]


class MessageEnd(NamedElement):
    sendMessage: umlproperty["Message", "Message"]
    receiveMessage: umlproperty["Message", "Message"]


class OccurrenceSpecification(InteractionFragment):
    toAfter: umlproperty[GeneralOrdering, collection[GeneralOrdering]]
    toBefore: umlproperty[GeneralOrdering, collection[GeneralOrdering]]
    finishExec: umlproperty[ExecutionOccurence, collection[ExecutionOccurence]]
    startExec: umlproperty[ExecutionOccurence, collection[ExecutionOccurence]]


class GeneralOrdering(NamedElement):
    before: umlproperty["OccurrenceSpecification", "OccurrenceSpecification"]
    after: umlproperty["OccurrenceSpecification", "OccurrenceSpecification"]


class Connector(Feature):
    kind: umlproperty[str, str]
    redefinedConnector: umlproperty[Connector, collection[Connector]]
    type: umlproperty["Association", "Association"]
    end: umlproperty[ConnectorEnd, collection[ConnectorEnd]]
    contract: umlproperty[Behavior, collection[Behavior]]


class ConnectorEnd(MultiplicityElement):
    role: umlproperty["ConnectableElement", "ConnectableElement"]
    partWithPort: umlproperty["Property", "Property"]
    definingEnd: umlproperty["Property", "Property"]


class FlowFinalNode(FinalNode):
    pass


class JoinNode(ControlNode):
    isCombineDuplicate: umlproperty[int, int]
    joinSpec: umlproperty[str, str]


class ForkNode(ControlNode):
    pass


class StateMachine(Behavior):
    region: umlproperty[Region, collection[Region]]
    extendedStateMachine: umlproperty["StateMachine", "StateMachine"]


class Region(Namespace, RedefinableElement):
    stateMachine: umlproperty["StateMachine", "StateMachine"]
    subvertex: umlproperty[Vertex, collection[Vertex]]
    state: umlproperty["State", "State"]
    extendedRegion: umlproperty[Region, collection[Region]]


# 30: override Transition
# Invert order of superclasses to avoid MRO issues
class Transition(RedefinableElement, NamedElement):
    kind: umlproperty[str, str]
    container: umlproperty[Region, Region]
    source: umlproperty[Vertex, Vertex]
    target: umlproperty[Vertex, Vertex]
    effect: umlproperty[Behavior, Behavior]
    guard: umlproperty[Constraint, Constraint]
    redefintionContext: umlproperty[Classifier, Classifier]
    redefinedTransition: umlproperty[Transition, Transition]



class Vertex(NamedElement):
    container: umlproperty["Region", "Region"]
    outgoing: umlproperty[Transition, collection[Transition]]
    incoming: umlproperty[Transition, collection[Transition]]


class Pseudostate(Vertex):
    kind: umlproperty[str, str]
    stateMachine: umlproperty["StateMachine", "StateMachine"]
    state: umlproperty["State", "State"]


class ConnectionPointReference(Vertex):
    entry: umlproperty[Pseudostate, collection[Pseudostate]]
    exit: umlproperty[Pseudostate, collection[Pseudostate]]
    state: umlproperty["State", "State"]


class State(Vertex, Namespace, RedefinableElement):
    entry: umlproperty["Behavior", "Behavior"]
    exit: umlproperty["Behavior", "Behavior"]
    doActivity: umlproperty["Behavior", "Behavior"]
    statevariant: umlproperty["Constraint", "Constraint"]
    submachine: umlproperty["StateMachine", "StateMachine"]
    redefinedState: umlproperty["State", "State"]


class FinalState(State):
    pass


class Port(Property):
    isBehavior: umlproperty[int, int]
    isService: umlproperty[int, int]


class Deployment(Dependency):
    deployedArtifact: umlproperty[DeployedArtifact, collection[DeployedArtifact]]


class ActivityPartition(ActivityGroup, NamedElement):
    isDimension: umlproperty[int, int]
    isExternal: umlproperty[int, int]
    node: umlproperty[ActivityNode, collection[ActivityNode]]
    represents: umlproperty["Element", "Element"]
    subpartition: umlproperty[ActivityPartition, collection[ActivityPartition]]


class MessageOccurrenceSpecification(MessageEnd, OccurrenceSpecification):
    pass


class AcceptEventAction(Action):
    isUnmarshall: umlproperty[int, int]
    result: umlproperty[OutputPin, collection[OutputPin]]


class ReplyAction(Action):
    replyValue: umlproperty["InputPin", "InputPin"]
    returnInformation: umlproperty["InputPin", "InputPin"]


class UnmarshallAction(Action):
    result: umlproperty[OutputPin, collection[OutputPin]]
    unmarshallType: umlproperty["Classifier", "Classifier"]
    object: umlproperty["InputPin", "InputPin"]


class AcceptCallAction(AcceptEventAction):
    returnInformation: umlproperty["OutputPin", "OutputPin"]


class InvocationAction(Action):
    pass


class SendSignalAction(InvocationAction):
    target: umlproperty[InputPin, collection[InputPin]]


class Collaboration(StructuredClassifier, BehavioredClassifier):
    collaborationRole: umlproperty[ConnectableElement, collection[ConnectableElement]]


class Trigger(NamedElement):
    event: umlproperty["Event", "Event"]


class Event(PackageableElement):
    pass


class ExecutionEvent(Event):
    pass


class CreationEvent(Event):
    pass


class MessageEvent(Event):
    pass


class DestructionEvent(Event):
    pass


class SendOperationEvent(MessageEvent):
    operation: umlproperty["Operation", "Operation"]


class SendSignalEvent(MessageEvent):
    signal: umlproperty["Signal", "Signal"]


class ReceiveOperationEvent(MessageEvent):
    operation: umlproperty["Operation", "Operation"]


class ReceiveSignalEvent(MessageEvent):
    signal: umlproperty["Signal", "Signal"]


class Signal(Classifier):
    ownedAttribute: umlproperty[Property, collection[Property]]


class Reception(BehavioralFeature):
    signal: umlproperty["Signal", "Signal"]


import gaphor.UML.uml2overrides as overrides
import gaphor.UML.umllex as umllex
# class 'ValueSpecification' has been stereotyped as 'SimpleAttribute'
# class 'InstanceValue' has been stereotyped as 'SimpleAttribute' too
# class 'Expression' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralSpecification' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralUnlimitedNatural' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralBoolean' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralInteger' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralString' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralNull' has been stereotyped as 'SimpleAttribute' too
# class 'OpaqueExpression' has been stereotyped as 'SimpleAttribute' too
Extension.isRequired = attribute('isRequired', int)
Feature.isStatic = attribute('isStatic', int, default=False)
RedefinableElement.isLeaf = attribute('isLeaf', int, default=True)
Generalization.isSubstitutable = attribute('isSubstitutable', int)
ObjectNode.ordering = enumeration('ordering', ('unordered', 'ordered', 'LIFO', 'FIFO'), 'FIFO')
ObjectNode.isControlType = attribute('isControlType', int, default=False)
StructuralFeature.isReadOnly = attribute('isReadOnly', int, default=False)
NamedElement.visibility = enumeration('visibility', ('public', 'private', 'package', 'protected'), 'public')
NamedElement.name = attribute('name', str)
# 48: override NamedElement.qualifiedName: property

NamedElement.qualifiedName = property(overrides.namedelement_qualifiedname, doc=overrides.namedelement_qualifiedname.__doc__)


Component.isIndirectlyInstantiated = attribute('isIndirectlyInstantiated', int, default=True)
Association.isDerived = attribute('isDerived', int, default=False)
PackageableElement.visibility = enumeration('visibility', ('public', 'private', 'package', 'protected'), 'public')
ElementImport.visibility = enumeration('visibility', ('public', 'private', 'package', 'protected'), 'public')
ElementImport.alias = attribute('alias', str)
MultiplicityElement.isUnique = attribute('isUnique', int, default=True)
MultiplicityElement.isOrdered = attribute('isOrdered', int, default=True)
Activity.body = attribute('body', str)
Activity.language = attribute('language', str)
Classifier.isAbstract = attribute('isAbstract', int, default=False)
Parameter.direction = enumeration('direction', ('inout', 'in', 'out', 'return'), 'in')
Operation.isQuery = attribute('isQuery', int, default=False)
Property.aggregation = enumeration('aggregation', ('none', 'shared', 'composite'), 'none')
Property.isDerivedUnion = attribute('isDerivedUnion', int, default=False)
Property.isDerived = attribute('isDerived', int, default=False)
Property.isReadOnly = attribute('isReadOnly', int, default=False)
# 102: override Property.navigability: property
Property.navigability = property(overrides.property_navigability, doc=overrides.property_navigability.__doc__)

Behavior.isReentrant = attribute('isReentrant', int)
BehavioralFeature.isAbstract = attribute('isAbstract', int)
Action.effect = attribute('effect', str)
Comment.body = attribute('body', str)
PackageImport.visibility = enumeration('visibility', ('public', 'private', 'package', 'protected'), 'public')
# 120: override Message.messageKind: property
Message.messageKind = property(overrides.message_messageKind, doc=overrides.message_messageKind.__doc__)

Message.messageSort = enumeration('messageSort', ('synchCall', 'asynchCall', 'asynchSignal', 'createMessage', 'deleteMessage', 'reply'), 'synchCall')
Connector.kind = enumeration('kind', ('assembly', 'delegation'), 'assembly')
JoinNode.isCombineDuplicate = attribute('isCombineDuplicate', int, default=True)
Transition.kind = enumeration('kind', ('internal', 'local', 'external'), 'internal')
Pseudostate.kind = enumeration('kind', ('initial', 'deepHistory', 'shallowHistory', 'join', 'fork', 'junction', 'choice', 'entryPoint', 'exitPoint', 'terminate'), 'initial')
Port.isBehavior = attribute('isBehavior', int)
Port.isService = attribute('isService', int)
ActivityPartition.isDimension = attribute('isDimension', int, default=False)
ActivityPartition.isExternal = attribute('isExternal', int, default=False)
AcceptEventAction.isUnmarshall = attribute('isUnmarshall', int, default=False)
Operation.precondition = association('precondition', Constraint, composite=True)
Package.ownedDiagram = association('ownedDiagram', Diagram, composite=True, opposite='package')
Diagram.package = association('package', Package, upper=1, opposite='ownedDiagram')
Package.nestedPackage = association('nestedPackage', Package, composite=True, opposite='package')
Package.package = association('package', Package, upper=1, opposite='nestedPackage')
NamedElement.clientDependency = association('clientDependency', Dependency, opposite='client')
Dependency.client = association('client', NamedElement, lower=1, opposite='clientDependency')
DecisionNode.decisionInput = association('decisionInput', Behavior, upper=1)
Activity.edge = association('edge', ActivityEdge, composite=True, opposite='activity')
ActivityEdge.activity = association('activity', Activity, upper=1, opposite='edge')
Substitution.contract = association('contract', Classifier, lower=1, upper=1)
Operation.bodyCondition = association('bodyCondition', Constraint, upper=1, composite=True)
# 'InstanceSpecification.specification' is a simple attribute
InstanceSpecification.specification = attribute('specification', str)
BehavioralFeature.method = association('method', Behavior)
Property.datatype = association('datatype', DataType, upper=1, opposite='ownedAttribute')
DataType.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='datatype')
TypedElement.type = association('type', Type, upper=1)
Element.presentation = association('presentation', Presentation, composite=True, opposite='subject')
# 27: override Presentation.subject
# Presentation.subject is directly defined in the Presentation class

ActivityParameterNode.parameter = association('parameter', Parameter, lower=1, upper=1)
Dependency.supplier = association('supplier', NamedElement, lower=1, opposite='supplierDependency')
NamedElement.supplierDependency = association('supplierDependency', Dependency, opposite='supplier')
Operation.redefinedOperation = association('redefinedOperation', Operation)
Activity.group = association('group', ActivityGroup, composite=True, opposite='activity')
ActivityGroup.activity = association('activity', Activity, upper=1, opposite='group')
Package.ownedClassifier = association('ownedClassifier', Type, composite=True, opposite='package')
Type.package = association('package', Package, upper=1, opposite='ownedClassifier')
Property.subsettedProperty = association('subsettedProperty', Property)
Property.classifier = association('classifier', Classifier, upper=1, opposite='attribute')
ExtensionEnd.type = association('type', Stereotype, lower=1, upper=1)
Profile.metamodelReference = association('metamodelReference', PackageImport, composite=True)
# 'ActivityEdge.guard' is a simple attribute
ActivityEdge.guard = attribute('guard', str)
Class.ownedOperation = association('ownedOperation', Operation, composite=True, opposite='class_')
Operation.class_ = association('class_', Class, upper=1, opposite='ownedOperation')
Enumeration.literal = association('literal', EnumerationLiteral, composite=True, opposite='enumeration')
EnumerationLiteral.enumeration = association('enumeration', Enumeration, upper=1, opposite='literal')
ActivityEdge.source = association('source', ActivityNode, lower=1, upper=1, opposite='outgoing')
ActivityNode.outgoing = association('outgoing', ActivityEdge, opposite='source')
Profile.ownedStereotype = association('ownedStereotype', Stereotype, composite=True)
Property.redefinedProperty = association('redefinedProperty', Property)
DataType.ownedOperation = association('ownedOperation', Operation, composite=True, opposite='datatype')
Operation.datatype = association('datatype', DataType, upper=1, opposite='ownedOperation')
Generalization.general = association('general', Classifier, lower=1, upper=1)
Classifier.ownedUseCase = association('ownedUseCase', UseCase, composite=True)
# 'MultiplicityElement.upperValue' is a simple attribute
MultiplicityElement.upperValue = attribute('upperValue', str)
PackageMerge.mergingPackage = association('mergingPackage', Package, lower=1, upper=1, opposite='packageExtension')
Package.packageExtension = association('packageExtension', PackageMerge, composite=True, opposite='mergingPackage')
Package.appliedProfile = association('appliedProfile', ProfileApplication, composite=True)
Activity.node = association('node', ActivityNode, composite=True)
# 'Parameter.defaultValue' is a simple attribute
Parameter.defaultValue = attribute('defaultValue', str)
Class.nestedClassifier = association('nestedClassifier', Classifier, composite=True)
# 'Slot.value' is a simple attribute
Slot.value = attribute('value', str)
Include.addition = association('addition', UseCase, lower=1, upper=1)
Realization.realizingClassifier = association('realizingClassifier', Classifier, lower=1, upper=1)
# 'TypedElement.typeValue' is a simple attribute
TypedElement.typeValue = attribute('typeValue', str)
Constraint.constrainedElement = association('constrainedElement', Element)
PackageMerge.mergedPackage = association('mergedPackage', Package, lower=1, upper=1)
BehavioralFeature.formalParameter = association('formalParameter', Parameter, composite=True, opposite='ownerFormalParam')
Parameter.ownerFormalParam = association('ownerFormalParam', BehavioralFeature, upper=1, opposite='formalParameter')
Class.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='class_')
Property.class_ = association('class_', Class, upper=1, opposite='ownedAttribute')
Extend.extendedCase = association('extendedCase', UseCase, lower=1, upper=1)
# 'Property.defaultValue' is a simple attribute
Property.defaultValue = attribute('defaultValue', str)
Namespace.ownedRule = association('ownedRule', Constraint, composite=True)
Property.association = association('association', Association, upper=1, opposite='memberEnd')
Association.memberEnd = association('memberEnd', Property, lower=2, composite=True, opposite='association')
Classifier.generalization = association('generalization', Generalization, composite=True, opposite='specific')
Generalization.specific = association('specific', Classifier, lower=1, upper=1, opposite='generalization')
Realization.abstraction = association('abstraction', Component, upper=1, opposite='realization')
Component.realization = association('realization', Realization, composite=True, opposite='abstraction')
# 'ValuePin.value_' is a simple attribute
ValuePin.value_ = attribute('value_', str)
BehavioralFeature.raisedException = association('raisedException', Type)
Activity.action = association('action', Action, composite=True)
# 'Abstraction.mapping' is a simple attribute
Abstraction.mapping = attribute('mapping', str)
ActivityNode.incoming = association('incoming', ActivityEdge, opposite='target')
ActivityEdge.target = association('target', ActivityNode, lower=1, upper=1, opposite='incoming')
Extend.extensionLocation = association('extensionLocation', ExtensionPoint, lower=1)
Property.interface_ = association('interface_', Interface, upper=1, opposite='ownedAttribute')
Interface.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='interface_')
ActivityGroup.edgeContents = association('edgeContents', ActivityEdge, opposite='inGroup')
ActivityEdge.inGroup = association('inGroup', ActivityGroup, opposite='edgeContents')
Slot.owningInstance = association('owningInstance', InstanceSpecification, lower=1, upper=1, opposite='slot')
InstanceSpecification.slot = association('slot', Slot, composite=True, opposite='owningInstance')
UseCase.subject = association('subject', Classifier)
Property.owningAssociation = association('owningAssociation', Association, upper=1, opposite='ownedEnd')
Association.ownedEnd = association('ownedEnd', Property, composite=True, opposite='owningAssociation')
Interface.redefinedInterface = association('redefinedInterface', Interface)
Artifact.manifestation = association('manifestation', Manifestation, composite=True)
ExtensionPoint.useCase = association('useCase', UseCase, lower=1, upper=1, opposite='extensionPoint')
UseCase.extensionPoint = association('extensionPoint', ExtensionPoint, opposite='useCase')
Operation.postcondition = association('postcondition', Constraint, composite=True)
Extension.ownedEnd = association('ownedEnd', ExtensionEnd, lower=1, upper=1, composite=True)
# 'Constraint.specification' is a simple attribute
Constraint.specification = attribute('specification', str)
Profile.metaclassReference = association('metaclassReference', ElementImport, composite=True)
Namespace.elementImport = association('elementImport', ElementImport, composite=True, opposite='importingNamespace')
ElementImport.importingNamespace = association('importingNamespace', Namespace, upper=1, opposite='elementImport')
# 'MultiplicityElement.lowerValue' is a simple attribute
MultiplicityElement.lowerValue = attribute('lowerValue', str)
Interface.nestedInterface = association('nestedInterface', Interface, composite=True)
InstanceSpecification.classifier = association('classifier', Classifier)
Interface.ownedOperation = association('ownedOperation', Operation, composite=True, opposite='interface_')
Operation.interface_ = association('interface_', Interface, upper=1, opposite='ownedOperation')
ElementImport.importedElement = association('importedElement', PackageableElement, lower=1, upper=1)
Parameter.ownerReturnParam = association('ownerReturnParam', BehavioralFeature, upper=1, opposite='returnResult')
BehavioralFeature.returnResult = association('returnResult', Parameter, composite=True, opposite='ownerReturnParam')
Classifier.redefinedClassifier = association('redefinedClassifier', Classifier)
Substitution.substitutingClassifier = association('substitutingClassifier', Classifier, lower=1, upper=1, opposite='substitution')
Classifier.substitution = association('substitution', Substitution, composite=True, opposite='substitutingClassifier')
Operation.raisedException = association('raisedException', Type)
PackageImport.importedPackage = association('importedPackage', Package, lower=1, upper=1)
StructuralFeature.slot = association('slot', Slot, composite=True, opposite='definingFeature')
Slot.definingFeature = association('definingFeature', StructuralFeature, lower=1, upper=1, opposite='slot')
Include.includingCase = association('includingCase', UseCase, lower=1, upper=1, opposite='include')
UseCase.include = association('include', Include, composite=True, opposite='includingCase')
Extend.extension = association('extension', UseCase, lower=1, upper=1, opposite='extend')
UseCase.extend = association('extend', Extend, composite=True, opposite='extension')
Extend.constraint = association('constraint', Constraint, upper=1, composite=True)
ProfileApplication.importedProfile = association('importedProfile', Profile, lower=1, upper=1)
Namespace.packageImport = association('packageImport', PackageImport, composite=True, opposite='importingNamespace')
PackageImport.importingNamespace = association('importingNamespace', Namespace, upper=1, opposite='packageImport')
Behavior.redefinedBehavior = association('redefinedBehavior', Behavior)
Element.ownedComment = association('ownedComment', Comment, opposite='annotatedElement')
Comment.annotatedElement = association('annotatedElement', Element, opposite='ownedComment')
Behavior.context = association('context', BehavioredClassifier, upper=1, opposite='ownedBehavior')
BehavioredClassifier.ownedBehavior = association('ownedBehavior', Behavior, composite=True, opposite='context')
ActivityGroup.nodeContents = association('nodeContents', ActivityNode, opposite='inGroup')
ActivityNode.inGroup = association('inGroup', ActivityGroup, opposite='nodeContents')
UseCase.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='useCase')
Property.useCase = association('useCase', UseCase, upper=1, opposite='ownedAttribute')
Property.actor = association('actor', Actor, upper=1, opposite='ownedAttribute')
Actor.ownedAttribute = association('ownedAttribute', Property, composite=True, opposite='actor')
InteractionFragment.enclosingInteraction = association('enclosingInteraction', Interaction, upper=1, opposite='fragment')
Interaction.fragment = association('fragment', InteractionFragment, opposite='enclosingInteraction')
StateInvariant.invariant = association('invariant', Constraint, lower=1, upper=1, composite=True)
Lifeline.coveredBy = association('coveredBy', InteractionFragment, opposite='covered')
InteractionFragment.covered = association('covered', Lifeline, lower=1, upper=1, opposite='coveredBy')
Lifeline.interaction = association('interaction', Interaction, lower=1, upper=1, opposite='lifeline')
Interaction.lifeline = association('lifeline', Lifeline, composite=True, opposite='interaction')
# 'Lifeline.discriminator' is a simple attribute
Lifeline.discriminator = attribute('discriminator', str)
# 'Message.argument' is a simple attribute
Message.argument = attribute('argument', str)
Message.signature = association('signature', NamedElement, upper=1)
MessageEnd.sendMessage = association('sendMessage', Message, upper=1, opposite='sendEvent')
Message.sendEvent = association('sendEvent', MessageEnd, upper=1, composite=True, opposite='sendMessage')
MessageEnd.receiveMessage = association('receiveMessage', Message, upper=1, opposite='receiveEvent')
Message.receiveEvent = association('receiveEvent', MessageEnd, upper=1, composite=True, opposite='receiveMessage')
Message.interaction = association('interaction', Interaction, lower=1, upper=1, opposite='message')
Interaction.message = association('message', Message, composite=True, opposite='interaction')
InteractionFragment.generalOrdering = association('generalOrdering', GeneralOrdering, composite=True)
GeneralOrdering.before = association('before', OccurrenceSpecification, lower=1, upper=1, opposite='toAfter')
OccurrenceSpecification.toAfter = association('toAfter', GeneralOrdering, opposite='before')
GeneralOrdering.after = association('after', OccurrenceSpecification, lower=1, upper=1, opposite='toBefore')
OccurrenceSpecification.toBefore = association('toBefore', GeneralOrdering, opposite='after')
ExecutionOccurence.finish = association('finish', OccurrenceSpecification, lower=1, upper=1, opposite='finishExec')
OccurrenceSpecification.finishExec = association('finishExec', ExecutionOccurence, opposite='finish')
ExecutionOccurence.start = association('start', OccurrenceSpecification, lower=1, upper=1, opposite='startExec')
OccurrenceSpecification.startExec = association('startExec', ExecutionOccurence, opposite='start')
ExecutionOccurence.behavior = association('behavior', Behavior)
StructuredClassifier.ownedConnector = association('ownedConnector', Connector, composite=True)
Connector.redefinedConnector = association('redefinedConnector', Connector)
Connector.type = association('type', Association, upper=1)
Connector.end = association('end', ConnectorEnd, lower=2, composite=True)
Connector.contract = association('contract', Behavior)
ConnectorEnd.role = association('role', ConnectableElement, upper=1, opposite='end')
ConnectableElement.end = association('end', ConnectorEnd, opposite='role')
StructuredClassifier.ownedAttribute = association('ownedAttribute', Property, composite=True)
# 'ObjectNode.upperBound' is a simple attribute
ObjectNode.upperBound = attribute('upperBound', str)
ObjectNode.selection = association('selection', Behavior, upper=1)
# 'JoinNode.joinSpec' is a simple attribute
JoinNode.joinSpec = attribute('joinSpec', str)
StateMachine.region = association('region', Region, lower=1, composite=True, opposite='stateMachine')
Region.stateMachine = association('stateMachine', StateMachine, upper=1, opposite='region')
Transition.container = association('container', Region, lower=1, upper=1)
Region.subvertex = association('subvertex', Vertex, composite=True, opposite='container')
Vertex.container = association('container', Region, upper=1, opposite='subvertex')
Transition.source = association('source', Vertex, lower=1, upper=1, opposite='outgoing')
Vertex.outgoing = association('outgoing', Transition, opposite='source')
Transition.target = association('target', Vertex, lower=1, upper=1, opposite='incoming')
Vertex.incoming = association('incoming', Transition, opposite='target')
ConnectionPointReference.entry = association('entry', Pseudostate)
ConnectionPointReference.exit = association('exit', Pseudostate)
Pseudostate.stateMachine = association('stateMachine', StateMachine, upper=1)
Region.state = association('state', State, upper=1)
Pseudostate.state = association('state', State, upper=1)
ConnectionPointReference.state = association('state', State, upper=1)
State.entry = association('entry', Behavior, upper=1, composite=True)
State.exit = association('exit', Behavior, upper=1, composite=True)
State.doActivity = association('doActivity', Behavior, upper=1, composite=True)
Transition.effect = association('effect', Behavior, upper=1, composite=True)
State.statevariant = association('statevariant', Constraint, upper=1, composite=True, opposite='owningState')
Constraint.owningState = association('owningState', State, upper=1, opposite='statevariant')
Transition.guard = association('guard', Constraint, upper=1, composite=True)
State.submachine = association('submachine', StateMachine, upper=1)
StateMachine.extendedStateMachine = association('extendedStateMachine', StateMachine, upper=1)
ConnectorEnd.partWithPort = association('partWithPort', Property, upper=1)
EncapsulatedClassifer.ownedPort = association('ownedPort', Port, composite=True)
Element.appliedStereotype = association('appliedStereotype', InstanceSpecification, opposite='extended')
InstanceSpecification.extended = association('extended', Element, opposite='appliedStereotype')
Node.nestedNode = association('nestedNode', Node, composite=True)
DeploymentTarget.deployment = association('deployment', Deployment, composite=True)
Deployment.deployedArtifact = association('deployedArtifact', DeployedArtifact)
ActivityNode.inPartition = association('inPartition', ActivityPartition, opposite='node')
ActivityPartition.node = association('node', ActivityNode, opposite='inPartition')
ActivityPartition.represents = association('represents', Element, upper=1)
ActivityPartition.subpartition = association('subpartition', ActivityPartition)
Association.navigableOwnedEnd = association('navigableOwnedEnd', Property)
AcceptEventAction.result = association('result', OutputPin, composite=True)
UnmarshallAction.result = association('result', OutputPin, composite=True)
AcceptCallAction.returnInformation = association('returnInformation', OutputPin, lower=1, upper=1, composite=True)
UnmarshallAction.unmarshallType = association('unmarshallType', Classifier, lower=1, upper=1)
UnmarshallAction.object = association('object', InputPin, lower=1, upper=1, composite=True)
ReplyAction.replyValue = association('replyValue', InputPin, upper=1, composite=True)
ReplyAction.returnInformation = association('returnInformation', InputPin, lower=1, upper=1, composite=True)
SendSignalAction.target = association('target', InputPin, composite=True)
Collaboration.collaborationRole = association('collaborationRole', ConnectableElement)
BehavioredClassifier.ownedTrigger = association('ownedTrigger', Trigger, composite=True)
Trigger.event = association('event', Event, lower=1, upper=1)
Signal.ownedAttribute = association('ownedAttribute', Property, composite=True)
Reception.signal = association('signal', Signal, upper=1)
Class.ownedReception = association('ownedReception', Reception, composite=True)
Interface.ownedReception = association('ownedReception', Reception, composite=True)
SendOperationEvent.operation = association('operation', Operation, lower=1, upper=1)
SendSignalEvent.signal = association('signal', Signal, lower=1, upper=1)
ReceiveOperationEvent.operation = association('operation', Operation, lower=1, upper=1)
ReceiveSignalEvent.signal = association('signal', Signal, lower=1, upper=1)
# 42: override MultiplicityElement.lower(MultiplicityElement.lowerValue): umlproperty[str, str]
MultiplicityElement.lower = derived('lower', object, 0, 1, lambda obj: [ obj.lowerValue ], MultiplicityElement.lowerValue)

# 45: override MultiplicityElement.upper(MultiplicityElement.upperValue): umlproperty[str, str]
MultiplicityElement.upper = derived('upper', object, 0, 1, lambda obj: [ obj.upperValue ], MultiplicityElement.upperValue)

# 96: override Property.isComposite(Property.aggregation): umlproperty[Namespace, Namespace]
Property.isComposite = derived('isComposite', bool, 0, 1, lambda obj: [obj.aggregation == 'composite'], Property.aggregation)

RedefinableElement.redefinedElement = derivedunion('redefinedElement', RedefinableElement, 0, '*', Property.redefinedProperty, Classifier.redefinedClassifier, Operation.redefinedOperation, Interface.redefinedInterface, Behavior.redefinedBehavior, Connector.redefinedConnector)
Classifier.attribute = derivedunion('attribute', Property, 0, '*', Class.ownedAttribute, DataType.ownedAttribute, Interface.ownedAttribute, UseCase.ownedAttribute, Actor.ownedAttribute, Signal.ownedAttribute)
Classifier.feature = derivedunion('feature', Feature, 0, '*', Interface.ownedOperation, UseCase.extensionPoint, DataType.ownedOperation, Class.ownedOperation, Association.ownedEnd, Classifier.attribute, StructuredClassifier.ownedConnector, Class.ownedReception, Interface.ownedReception)
Feature.featuringClassifier = derivedunion('featuringClassifier', Classifier, 1, '*', Property.class_, Property.owningAssociation, Operation.class_, Operation.datatype, Property.datatype, Operation.interface_)
# 93: override Property.opposite: property
Property.opposite = property(overrides.property_opposite, doc=overrides.property_opposite.__doc__)

BehavioralFeature.parameter = derivedunion('parameter', Parameter, 0, '*', BehavioralFeature.returnResult, BehavioralFeature.formalParameter)
Action.output = derivedunion('output', OutputPin, 0, '*')
Transition.redefintionContext = derivedunion('redefintionContext', Classifier, 1, 1)
RedefinableElement.redefinitionContext = derivedunion('redefinitionContext', Classifier, 0, '*', Operation.class_, Property.classifier, Operation.datatype, Transition.redefintionContext)
NamedElement.namespace = derivedunion('namespace', Namespace, 0, 1, Parameter.ownerReturnParam, Property.interface_, Property.class_, Property.owningAssociation, Operation.class_, EnumerationLiteral.enumeration, Diagram.package, Operation.datatype, Type.package, Property.datatype, Operation.interface_, Package.package, Parameter.ownerFormalParam, Property.useCase, Property.actor, Lifeline.interaction, Message.interaction, Region.stateMachine, Transition.container, Vertex.container, Pseudostate.stateMachine, Region.state, ConnectionPointReference.state)
Namespace.ownedMember = derivedunion('ownedMember', NamedElement, 0, '*', Interface.ownedOperation, Enumeration.literal, Package.ownedDiagram, Namespace.ownedRule, UseCase.extensionPoint, DataType.ownedOperation, Operation.precondition, BehavioralFeature.returnResult, Profile.ownedStereotype, Class.nestedClassifier, Class.ownedAttribute, BehavioralFeature.formalParameter, Classifier.ownedUseCase, DataType.ownedAttribute, Class.ownedOperation, Operation.postcondition, Association.ownedEnd, Package.ownedClassifier, Interface.ownedAttribute, Operation.bodyCondition, Extend.constraint, Package.nestedPackage, BehavioredClassifier.ownedBehavior, UseCase.ownedAttribute, Actor.ownedAttribute, StateInvariant.invariant, Interaction.lifeline, Interaction.message, StateMachine.region, Region.subvertex, Node.nestedNode, BehavioredClassifier.ownedTrigger, Signal.ownedAttribute, Class.ownedReception, Interface.ownedReception)
# 82: override Classifier.general: property
Classifier.general = property(lambda self: [g.general for g in self.generalization], doc="""
    Return a list of all superclasses for class (iterating the Generalizations.
    """)

# 53: override Association.endType(Association.memberEnd, Property.type): umlproperty[Type, collection[Type]]

# References the classifiers that are used as types of the ends of the
# association.

Association.endType = derived('endType', Type, 0, '*', lambda self: [end.type for end in self.memberEnd if end], Association.memberEnd, Property.type)


# 99: override Constraint.context: umlproperty[Namespace, Namespace]
Constraint.context = derivedunion('context', Namespace, 0, 1)

# 105: override Operation.type: umlproperty[DataType, DataType]
Operation.type = derivedunion('type', DataType, 0, 1)

# 73: override Extension.metaclass(Extension.ownedEnd, Association.memberEnd): property
# Don't use derived() now, it can not deal with a [0..1] property derived from a [0..*] property.
#Extension.metaclass = derived('metaclass', Class, 0, 1, Extension.ownedEnd, Association.memberEnd)
#Extension.metaclass.filter = extension_metaclass
Extension.metaclass = property(overrides.extension_metaclass, doc=overrides.extension_metaclass.__doc__)

# 61: override Class.extension(Extension.metaclass): property
# See https://www.omg.org/spec/UML/2.5/PDF, section 11.8.3.6, page 219
# It defines `Extension.allInstances()`, which basically means we have to query the element factory.

# TODO: use those as soon as Extension.metaclass can be used.
#Class.extension = derived('extension', Extension, 0, '*', class_extension, Extension.metaclass)

Class.extension = property(lambda self: self.model.lselect(lambda e: e.isKindOf(Extension) and self is e.metaclass), doc=\
"""References the Extensions that specify additional properties of the
metaclass. The property is derived from the extensions whose memberEnds
are typed by the Class.""")

DirectedRelationship.target = derivedunion('target', Element, 1, '*', PackageImport.importedPackage, PackageMerge.mergedPackage, Generalization.general, Include.addition, Extend.extendedCase, Realization.realizingClassifier, ElementImport.importedElement, Substitution.contract)
DirectedRelationship.source = derivedunion('source', Element, 1, '*', Extend.extension, Realization.abstraction, Substitution.substitutingClassifier, Include.includingCase, ElementImport.importingNamespace, Generalization.specific, PackageImport.importingNamespace, PackageMerge.mergingPackage)
Action.context_ = derivedunion('context_', Classifier, 0, 1)
Relationship.relatedElement = derivedunion('relatedElement', Element, 1, '*', DirectedRelationship.target, DirectedRelationship.source)
ActivityGroup.superGroup = derivedunion('superGroup', ActivityGroup, 0, 1)
ActivityGroup.subgroup = derivedunion('subgroup', ActivityGroup, 0, '*', ActivityPartition.subpartition)
# 79: override Classifier.inheritedMember: umlproperty[NamedElement, collection[NamedElement]]
Classifier.inheritedMember = derivedunion('inheritedMember', NamedElement, 0, '*')

StructuredClassifier.role = derivedunion('role', ConnectableElement, 0, '*', StructuredClassifier.ownedAttribute, Collaboration.collaborationRole)
Namespace.member = derivedunion('member', NamedElement, 0, '*', BehavioralFeature.parameter, Namespace.ownedMember, Association.memberEnd, Classifier.inheritedMember, StructuredClassifier.role)
# 117: override Component.required: property
Component.required = property(overrides.component_required, doc=overrides.component_required.__doc__)

# 90: override Namespace.importedMember: umlproperty[PackageableElement, collection[PackageableElement]]
Namespace.importedMember = derivedunion('importedMember', PackageableElement, 0, '*')

Action.input = derivedunion('input', InputPin, 0, '*', SendSignalAction.target)
# 114: override Component.provided: property
Component.provided = property(overrides.component_provided, doc=overrides.component_provided.__doc__)

Element.owner = derivedunion('owner', Element, 0, 1, Slot.owningInstance, Realization.abstraction, ElementImport.importingNamespace, Generalization.specific, ActivityEdge.activity, ActivityGroup.superGroup, ActivityGroup.activity, PackageImport.importingNamespace, PackageMerge.mergingPackage, NamedElement.namespace, Pseudostate.state)
Element.ownedElement = derivedunion('ownedElement', Element, 0, '*', Artifact.manifestation, Element.ownedComment, Action.input, Classifier.generalization, Namespace.ownedMember, Namespace.elementImport, Activity.group, Component.realization, Namespace.packageImport, Package.packageExtension, Substitution.contract, ActivityGroup.subgroup, Activity.edge, Activity.node, Action.output, Interaction.fragment, InteractionFragment.generalOrdering, Connector.end, State.entry, State.exit, State.doActivity, Transition.effect, State.statevariant, Transition.guard, DeploymentTarget.deployment)
ConnectorEnd.definingEnd = derivedunion('definingEnd', Property, 0, 1)
# 123: override StructuredClassifier.part: property
StructuredClassifier.part = property(lambda self: tuple(a for a in self.ownedAttribute if a.isComposite), doc="""
    Properties owned by a classifier by composition.
""")

# 87: override Class.superClass: property
Class.superClass = Classifier.general

ActivityNode.redefinedElement = redefine(ActivityNode, 'redefinedElement', ActivityNode, RedefinableElement.redefinedElement)
Implementation.contract = redefine(Implementation, 'contract', Interface, Dependency.supplier)
BehavioredClassifier.implementation = redefine(BehavioredClassifier, 'implementation', Implementation, NamedElement.clientDependency)
Implementation.implementatingClassifier = redefine(Implementation, 'implementatingClassifier', BehavioredClassifier, Dependency.client)
Parameter.operation = redefine(Parameter, 'operation', Operation, Parameter.ownerFormalParam)
Operation.formalParameter = redefine(Operation, 'formalParameter', Parameter, BehavioralFeature.formalParameter)
ActivityEdge.redefinedElement = redefine(ActivityEdge, 'redefinedElement', ActivityEdge, RedefinableElement.redefinedElement)
Package.ownedMember = redefine(Package, 'ownedMember', PackageableElement, Namespace.ownedMember)
Component.ownedMember = redefine(Component, 'ownedMember', PackageableElement, Namespace.ownedMember)
Region.extendedRegion = redefine(Region, 'extendedRegion', Region, RedefinableElement.redefinedElement)
State.redefinedState = redefine(State, 'redefinedState', State, RedefinableElement.redefinedElement)
Transition.redefinedTransition = redefine(Transition, 'redefinedTransition', Transition, RedefinableElement.redefinedElement)
# 108: override Lifeline.parse: Callable[[Lifeline, str], None]
Lifeline.parse = umllex.parse_lifeline

# 111: override Lifeline.render: Callable[[Lifeline], str]
Lifeline.render = umllex.render_lifeline

