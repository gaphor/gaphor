# This file is generated by build_uml.py. DO NOT EDIT!

from typing import Any, Sequence
from gaphor.UML.properties import (
    umlproperty,
    association,
    attribute,
    enumeration,
    derived,
    derivedunion,
    redefine,
)

AssociationType = association
AttributeType = attribute
EnumerationType = enumeration
DerivedType = derived
DerivedunionType = umlproperty
RedefineType = umlproperty

# 14: override Element
from gaphor.UML.element import Element


class NamedElement(Element):
    visibility: umlproperty[str, str]
    name: umlproperty[str, str]
    qualifiedName: Any
    clientDependency: umlproperty["Dependency", Sequence["Dependency"]]
    supplierDependency: umlproperty["Dependency", Sequence["Dependency"]]
    namespace: umlproperty["Namespace", Sequence["Namespace"]]


class PackageableElement(NamedElement):
    visibility: umlproperty[str, str]


class InstanceSpecification(PackageableElement):
    specification: umlproperty[str, str]
    slot: umlproperty["Slot", Sequence["Slot"]]
    classifier: umlproperty["Classifier", Sequence["Classifier"]]
    extended: umlproperty["Element", Sequence["Element"]]


class EnumerationLiteral(InstanceSpecification):
    enumeration: umlproperty["Enumeration", Sequence["Enumeration"]]


class Relationship(Element):
    relatedElement: umlproperty["Element", Sequence["Element"]]


class DirectedRelationship(Relationship):
    target: umlproperty["Element", Sequence["Element"]]
    source: umlproperty["Element", Sequence["Element"]]


class PackageMerge(DirectedRelationship):
    mergingPackage: umlproperty["Package", Sequence["Package"]]
    mergedPackage: umlproperty["Package", Sequence["Package"]]


class Namespace(NamedElement):
    ownedRule: umlproperty["Constraint", Sequence["Constraint"]]
    elementImport: umlproperty["ElementImport", Sequence["ElementImport"]]
    packageImport: umlproperty["PackageImport", Sequence["PackageImport"]]
    ownedMember: umlproperty["NamedElement", Sequence["NamedElement"]]
    member: umlproperty["NamedElement", Sequence["NamedElement"]]
    importedMember: umlproperty["PackageableElement", Sequence["PackageableElement"]]


class Type(PackageableElement):
    package: umlproperty["Package", Sequence["Package"]]


class RedefinableElement(NamedElement):
    isLeaf: umlproperty[int, int]
    redefinedElement: umlproperty["RedefinableElement", Sequence["RedefinableElement"]]
    redefinitionContext: umlproperty["Classifier", Sequence["Classifier"]]


class Classifier(Namespace, Type, RedefinableElement):
    isAbstract: umlproperty[int, int]
    ownedUseCase: umlproperty["UseCase", Sequence["UseCase"]]
    generalization: umlproperty["Generalization", Sequence["Generalization"]]
    redefinedClassifier: umlproperty["Classifier", Sequence["Classifier"]]
    substitution: umlproperty["Substitution", Sequence["Substitution"]]
    attribute: umlproperty["Property", Sequence["Property"]]
    feature: umlproperty["Feature", Sequence["Feature"]]
    general: umlproperty["Classifier", Sequence["Classifier"]]
    inheritedMember: umlproperty["NamedElement", Sequence["NamedElement"]]


class Association(Classifier, Relationship):
    isDerived: umlproperty[int, int]
    memberEnd: umlproperty["Property", Sequence["Property"]]
    ownedEnd: umlproperty["Property", Sequence["Property"]]
    navigableOwnedEnd: umlproperty["Property", Sequence["Property"]]
    endType: umlproperty["Type", Sequence["Type"]]


class Extension(Association):
    isRequired: umlproperty[int, int]
    ownedEnd: umlproperty["ExtensionEnd", Sequence["ExtensionEnd"]]
    metaclass: umlproperty["Class", Sequence["Class"]]


class Actor(Classifier):
    ownedAttribute: umlproperty["Property", Sequence["Property"]]


class ActivityNode(RedefinableElement):
    outgoing: umlproperty["ActivityEdge", Sequence["ActivityEdge"]]
    incoming: umlproperty["ActivityEdge", Sequence["ActivityEdge"]]
    inGroup: umlproperty["ActivityGroup", Sequence["ActivityGroup"]]
    inPartition: umlproperty["ActivityPartition", Sequence["ActivityPartition"]]
    redefinedElement: umlproperty["ActivityNode", Sequence["ActivityNode"]]


class ControlNode(ActivityNode):
    pass


class MergeNode(ControlNode):
    pass


class Feature(RedefinableElement):
    isStatic: umlproperty[int, int]
    featuringClassifier: umlproperty["Classifier", Sequence["Classifier"]]


class ActivityEdge(RedefinableElement):
    activity: umlproperty["Activity", Sequence["Activity"]]
    guard: umlproperty[str, str]
    source: umlproperty["ActivityNode", Sequence["ActivityNode"]]
    target: umlproperty["ActivityNode", Sequence["ActivityNode"]]
    inGroup: umlproperty["ActivityGroup", Sequence["ActivityGroup"]]
    redefinedElement: umlproperty["ActivityEdge", Sequence["ActivityEdge"]]


class ObjectFlow(ActivityEdge):
    pass


class FinalNode(ControlNode):
    pass


class ActivityFinalNode(FinalNode):
    pass


class CommunicationPath(Association):
    pass


class Dependency(DirectedRelationship, PackageableElement):
    client: umlproperty["NamedElement", Sequence["NamedElement"]]
    supplier: umlproperty["NamedElement", Sequence["NamedElement"]]


class Permission(Dependency):
    pass


class Abstraction(Dependency):
    mapping: umlproperty[str, str]


class Realization(Abstraction):
    realizingClassifier: umlproperty["Classifier", Sequence["Classifier"]]
    abstraction: umlproperty["Component", Sequence["Component"]]


class TypedElement(NamedElement):
    type: umlproperty["Type", Sequence["Type"]]
    typeValue: umlproperty[str, str]


class ObjectNode(TypedElement, ActivityNode):
    ordering: umlproperty[str, str]
    isControlType: umlproperty[int, int]
    upperBound: umlproperty[str, str]
    selection: umlproperty["Behavior", Sequence["Behavior"]]


class Pin(ObjectNode):
    pass


class Generalization(DirectedRelationship):
    isSubstitutable: umlproperty[int, int]
    general: umlproperty["Classifier", Sequence["Classifier"]]
    specific: umlproperty["Classifier", Sequence["Classifier"]]


class BehavioredClassifier(Classifier):
    ownedBehavior: umlproperty["Behavior", Sequence["Behavior"]]
    ownedTrigger: umlproperty["Trigger", Sequence["Trigger"]]
    implementation: umlproperty["Implementation", Sequence["Implementation"]]


class StructuredClassifier(Classifier):
    ownedConnector: umlproperty["Connector", Sequence["Connector"]]
    ownedAttribute: umlproperty["Property", Sequence["Property"]]
    role: umlproperty["ConnectableElement", Sequence["ConnectableElement"]]
    part: umlproperty["Property", Sequence["Property"]]


class EncapsulatedClassifer(StructuredClassifier):
    ownedPort: umlproperty["Port", Sequence["Port"]]


class Class(BehavioredClassifier, EncapsulatedClassifer):
    ownedOperation: umlproperty["Operation", Sequence["Operation"]]
    nestedClassifier: umlproperty["Classifier", Sequence["Classifier"]]
    ownedAttribute: umlproperty["Property", Sequence["Property"]]
    ownedReception: umlproperty["Reception", Sequence["Reception"]]
    extension: umlproperty["Extension", Sequence["Extension"]]
    superClass: umlproperty["Class", Sequence["Class"]]


class DeploymentTarget(NamedElement):
    deployment: umlproperty["Deployment", Sequence["Deployment"]]


class Node(Class, DeploymentTarget):
    nestedNode: umlproperty["Node", Sequence["Node"]]


class Device(Node):
    pass


class MultiplicityElement(Element):
    isUnique: umlproperty[int, int]
    isOrdered: umlproperty[int, int]
    upperValue: umlproperty[str, str]
    lowerValue: umlproperty[str, str]
    lower: Any
    upper: Any


class StructuralFeature(MultiplicityElement, TypedElement, Feature):
    isReadOnly: umlproperty[int, int]
    slot: umlproperty["Slot", Sequence["Slot"]]


class UseCase(BehavioredClassifier):
    subject: umlproperty["Classifier", Sequence["Classifier"]]
    extensionPoint: umlproperty["ExtensionPoint", Sequence["ExtensionPoint"]]
    include: umlproperty["Include", Sequence["Include"]]
    extend: umlproperty["Extend", Sequence["Extend"]]
    ownedAttribute: umlproperty["Property", Sequence["Property"]]


class InputPin(Pin):
    pass


class Manifestation(Abstraction):
    pass


class Component(Class):
    isIndirectlyInstantiated: umlproperty[int, int]
    realization: umlproperty["Realization", Sequence["Realization"]]
    required: umlproperty["Interface", Sequence["Interface"]]
    provided: umlproperty["Interface", Sequence["Interface"]]
    ownedMember: umlproperty["PackageableElement", Sequence["PackageableElement"]]


class ConnectableElement(TypedElement):
    end: umlproperty["ConnectorEnd", Sequence["ConnectorEnd"]]


class Interface(Classifier, ConnectableElement):
    ownedAttribute: umlproperty["Property", Sequence["Property"]]
    redefinedInterface: umlproperty["Interface", Sequence["Interface"]]
    nestedInterface: umlproperty["Interface", Sequence["Interface"]]
    ownedOperation: umlproperty["Operation", Sequence["Operation"]]
    ownedReception: umlproperty["Reception", Sequence["Reception"]]


class Include(DirectedRelationship):
    addition: umlproperty["UseCase", Sequence["UseCase"]]
    includingCase: umlproperty["UseCase", Sequence["UseCase"]]


class PackageImport(DirectedRelationship):
    visibility: umlproperty[str, str]
    importedPackage: umlproperty["Package", Sequence["Package"]]
    importingNamespace: umlproperty["Namespace", Sequence["Namespace"]]


class ProfileApplication(PackageImport):
    importedProfile: umlproperty["Profile", Sequence["Profile"]]


class ExtensionPoint(RedefinableElement):
    useCase: umlproperty["UseCase", Sequence["UseCase"]]


class Usage(Dependency):
    pass


class ElementImport(DirectedRelationship):
    visibility: umlproperty[str, str]
    alias: umlproperty[str, str]
    importingNamespace: umlproperty["Namespace", Sequence["Namespace"]]
    importedElement: umlproperty["PackageableElement", Sequence["PackageableElement"]]


class Property(StructuralFeature, ConnectableElement):
    aggregation: umlproperty[str, str]
    isDerivedUnion: umlproperty[int, int]
    isDerived: umlproperty[int, int]
    isReadOnly: umlproperty[int, int]
    navigability: Any
    datatype: umlproperty["DataType", Sequence["DataType"]]
    subsettedProperty: umlproperty["Property", Sequence["Property"]]
    classifier: umlproperty["Classifier", Sequence["Classifier"]]
    redefinedProperty: umlproperty["Property", Sequence["Property"]]
    class_: umlproperty["Class", Sequence["Class"]]
    defaultValue: umlproperty[str, str]
    association: umlproperty["Association", Sequence["Association"]]
    interface_: umlproperty["Interface", Sequence["Interface"]]
    owningAssociation: umlproperty["Association", Sequence["Association"]]
    useCase: umlproperty["UseCase", Sequence["UseCase"]]
    actor: umlproperty["Actor", Sequence["Actor"]]
    isComposite: Any
    opposite: umlproperty["Property", Sequence["Property"]]


class ExtensionEnd(Property):
    type: umlproperty["Stereotype", Sequence["Stereotype"]]


class DataType(Classifier):
    ownedAttribute: umlproperty["Property", Sequence["Property"]]
    ownedOperation: umlproperty["Operation", Sequence["Operation"]]


class Enumeration(DataType):
    literal: umlproperty["EnumerationLiteral", Sequence["EnumerationLiteral"]]


class Slot(Element):
    value: umlproperty[str, str]
    owningInstance: umlproperty[
        "InstanceSpecification", Sequence["InstanceSpecification"]
    ]
    definingFeature: umlproperty["StructuralFeature", Sequence["StructuralFeature"]]


class ExecutableNode(ActivityNode):
    pass


class InitialNode(ControlNode):
    pass


class Stereotype(Class):
    pass


# 17: override Diagram
from gaphor.UML.diagram import Diagram


class DeployedArtifact(NamedElement):
    pass


class Artifact(Classifier, DeployedArtifact):
    manifestation: umlproperty["Manifestation", Sequence["Manifestation"]]


class ActivityParameterNode(ObjectNode):
    parameter: umlproperty["Parameter", Sequence["Parameter"]]


class PrimitiveType(DataType):
    pass


class DecisionNode(ControlNode):
    decisionInput: umlproperty["Behavior", Sequence["Behavior"]]


class Package(Namespace, PackageableElement):
    ownedDiagram: umlproperty["Diagram", Sequence["Diagram"]]
    nestedPackage: umlproperty["Package", Sequence["Package"]]
    package: umlproperty["Package", Sequence["Package"]]
    ownedClassifier: umlproperty["Type", Sequence["Type"]]
    packageExtension: umlproperty["PackageMerge", Sequence["PackageMerge"]]
    appliedProfile: umlproperty["ProfileApplication", Sequence["ProfileApplication"]]
    ownedMember: umlproperty["PackageableElement", Sequence["PackageableElement"]]


class Profile(Package):
    metamodelReference: umlproperty["PackageImport", Sequence["PackageImport"]]
    ownedStereotype: umlproperty["Stereotype", Sequence["Stereotype"]]
    metaclassReference: umlproperty["ElementImport", Sequence["ElementImport"]]


class Behavior(Class):
    isReentrant: umlproperty[int, int]
    redefinedBehavior: umlproperty["Behavior", Sequence["Behavior"]]
    context: umlproperty["BehavioredClassifier", Sequence["BehavioredClassifier"]]


class Activity(Behavior):
    body: umlproperty[str, str]
    language: umlproperty[str, str]
    edge: umlproperty["ActivityEdge", Sequence["ActivityEdge"]]
    group: umlproperty["ActivityGroup", Sequence["ActivityGroup"]]
    node: umlproperty["ActivityNode", Sequence["ActivityNode"]]
    action: umlproperty["Action", Sequence["Action"]]


class Implementation(Realization):
    contract: umlproperty["Interface", Sequence["Interface"]]
    implementatingClassifier: umlproperty[
        "BehavioredClassifier", Sequence["BehavioredClassifier"]
    ]


class Parameter(TypedElement, MultiplicityElement):
    direction: umlproperty[str, str]
    defaultValue: umlproperty[str, str]
    ownerFormalParam: umlproperty["BehavioralFeature", Sequence["BehavioralFeature"]]
    ownerReturnParam: umlproperty["BehavioralFeature", Sequence["BehavioralFeature"]]
    operation: umlproperty["Operation", Sequence["Operation"]]


# 20: override Presentation
from gaphor.UML.presentation import Presentation


class BehavioralFeature(Feature, Namespace):
    isAbstract: umlproperty[int, int]
    method: umlproperty["Behavior", Sequence["Behavior"]]
    formalParameter: umlproperty["Parameter", Sequence["Parameter"]]
    raisedException: umlproperty["Type", Sequence["Type"]]
    returnResult: umlproperty["Parameter", Sequence["Parameter"]]
    parameter: umlproperty["Parameter", Sequence["Parameter"]]


class Operation(BehavioralFeature):
    isQuery: umlproperty[int, int]
    precondition: umlproperty["Constraint", Sequence["Constraint"]]
    bodyCondition: umlproperty["Constraint", Sequence["Constraint"]]
    redefinedOperation: umlproperty["Operation", Sequence["Operation"]]
    class_: umlproperty["Class", Sequence["Class"]]
    datatype: umlproperty["DataType", Sequence["DataType"]]
    postcondition: umlproperty["Constraint", Sequence["Constraint"]]
    interface_: umlproperty["Interface", Sequence["Interface"]]
    raisedException: umlproperty["Type", Sequence["Type"]]
    type: umlproperty["Type", Sequence["Type"]]
    formalParameter: umlproperty["Parameter", Sequence["Parameter"]]


class ControlFlow(ActivityEdge):
    pass


class Substitution(Realization):
    contract: umlproperty["Classifier", Sequence["Classifier"]]
    substitutingClassifier: umlproperty["Classifier", Sequence["Classifier"]]


class OutputPin(Pin):
    pass


class ValuePin(InputPin):
    value_: umlproperty[str, str]


class Action(ExecutableNode):
    effect: umlproperty[str, str]
    output: umlproperty["OutputPin", Sequence["OutputPin"]]
    context_: umlproperty["Classifier", Sequence["Classifier"]]
    input: umlproperty["InputPin", Sequence["InputPin"]]


class Comment(Element):
    body: umlproperty[str, str]
    annotatedElement: umlproperty["Element", Sequence["Element"]]


class ExecutionEnvironment(Node):
    pass


class Extend(DirectedRelationship):
    extendedCase: umlproperty["UseCase", Sequence["UseCase"]]
    extensionLocation: umlproperty["ExtensionPoint", Sequence["ExtensionPoint"]]
    extension: umlproperty["UseCase", Sequence["UseCase"]]
    constraint: umlproperty["Constraint", Sequence["Constraint"]]


class ActivityGroup(Element):
    activity: umlproperty["Activity", Sequence["Activity"]]
    edgeContents: umlproperty["ActivityEdge", Sequence["ActivityEdge"]]
    nodeContents: umlproperty["ActivityNode", Sequence["ActivityNode"]]
    superGroup: umlproperty["ActivityGroup", Sequence["ActivityGroup"]]
    subgroup: umlproperty["ActivityGroup", Sequence["ActivityGroup"]]


class Constraint(PackageableElement):
    constrainedElement: umlproperty["Element", Sequence["Element"]]
    specification: umlproperty[str, str]
    owningState: umlproperty["State", Sequence["State"]]
    context: umlproperty["Namespace", Sequence["Namespace"]]


class InteractionFragment(NamedElement):
    enclosingInteraction: umlproperty["Interaction", Sequence["Interaction"]]
    covered: umlproperty["Lifeline", Sequence["Lifeline"]]
    generalOrdering: umlproperty["GeneralOrdering", Sequence["GeneralOrdering"]]


class Interaction(Behavior, InteractionFragment):
    fragment: umlproperty["InteractionFragment", Sequence["InteractionFragment"]]
    lifeline: umlproperty["Lifeline", Sequence["Lifeline"]]
    message: umlproperty["Message", Sequence["Message"]]


class ExecutionOccurence(InteractionFragment):
    finish: umlproperty["OccurrenceSpecification", Sequence["OccurrenceSpecification"]]
    start: umlproperty["OccurrenceSpecification", Sequence["OccurrenceSpecification"]]
    behavior: umlproperty["Behavior", Sequence["Behavior"]]


class StateInvariant(InteractionFragment):
    invariant: umlproperty["Constraint", Sequence["Constraint"]]


class Lifeline(NamedElement):
    coveredBy: umlproperty["InteractionFragment", Sequence["InteractionFragment"]]
    interaction: umlproperty["Interaction", Sequence["Interaction"]]
    discriminator: umlproperty[str, str]
    parse: Any
    render: Any


class Message(NamedElement):
    messageKind: Any
    messageSort: umlproperty[str, str]
    argument: umlproperty[str, str]
    signature: umlproperty["NamedElement", Sequence["NamedElement"]]
    sendEvent: umlproperty["MessageEnd", Sequence["MessageEnd"]]
    receiveEvent: umlproperty["MessageEnd", Sequence["MessageEnd"]]
    interaction: umlproperty["Interaction", Sequence["Interaction"]]


class MessageEnd(NamedElement):
    sendMessage: umlproperty["Message", Sequence["Message"]]
    receiveMessage: umlproperty["Message", Sequence["Message"]]


class OccurrenceSpecification(InteractionFragment):
    toAfter: umlproperty["GeneralOrdering", Sequence["GeneralOrdering"]]
    toBefore: umlproperty["GeneralOrdering", Sequence["GeneralOrdering"]]
    finishExec: umlproperty["ExecutionOccurence", Sequence["ExecutionOccurence"]]
    startExec: umlproperty["ExecutionOccurence", Sequence["ExecutionOccurence"]]


class GeneralOrdering(NamedElement):
    before: umlproperty["OccurrenceSpecification", Sequence["OccurrenceSpecification"]]
    after: umlproperty["OccurrenceSpecification", Sequence["OccurrenceSpecification"]]


class Connector(Feature):
    kind: umlproperty[str, str]
    redefinedConnector: umlproperty["Connector", Sequence["Connector"]]
    type: umlproperty["Association", Sequence["Association"]]
    end: umlproperty["ConnectorEnd", Sequence["ConnectorEnd"]]
    contract: umlproperty["Behavior", Sequence["Behavior"]]


class ConnectorEnd(MultiplicityElement):
    role: umlproperty["ConnectableElement", Sequence["ConnectableElement"]]
    partWithPort: umlproperty["Property", Sequence["Property"]]
    definingEnd: umlproperty["Property", Sequence["Property"]]


class FlowFinalNode(FinalNode):
    pass


class JoinNode(ControlNode):
    isCombineDuplicate: umlproperty[int, int]
    joinSpec: umlproperty[str, str]


class ForkNode(ControlNode):
    pass


class StateMachine(Behavior):
    region: umlproperty["Region", Sequence["Region"]]
    extendedStateMachine: umlproperty["StateMachine", Sequence["StateMachine"]]


class Region(Namespace, RedefinableElement):
    stateMachine: umlproperty["StateMachine", Sequence["StateMachine"]]
    subvertex: umlproperty["Vertex", Sequence["Vertex"]]
    state: umlproperty["State", Sequence["State"]]
    extendedRegion: umlproperty["Region", Sequence["Region"]]


# 23: override Transition
# Invert order of superclasses to avoid MRO issues
class Transition(RedefinableElement, NamedElement):
    kind: EnumerationType
    container: AssociationType
    source: AssociationType
    target: AssociationType
    effect: AssociationType
    guard: AssociationType
    redefintionContext: DerivedunionType
    redefinedTransition: RedefineType


class Vertex(NamedElement):
    container: umlproperty["Region", Sequence["Region"]]
    outgoing: umlproperty["Transition", Sequence["Transition"]]
    incoming: umlproperty["Transition", Sequence["Transition"]]


class Pseudostate(Vertex):
    kind: umlproperty[str, str]
    stateMachine: umlproperty["StateMachine", Sequence["StateMachine"]]
    state: umlproperty["State", Sequence["State"]]


class ConnectionPointReference(Vertex):
    entry: umlproperty["Pseudostate", Sequence["Pseudostate"]]
    exit: umlproperty["Pseudostate", Sequence["Pseudostate"]]
    state: umlproperty["State", Sequence["State"]]


class State(Vertex, Namespace, RedefinableElement):
    entry: umlproperty["Behavior", Sequence["Behavior"]]
    exit: umlproperty["Behavior", Sequence["Behavior"]]
    doActivity: umlproperty["Behavior", Sequence["Behavior"]]
    statevariant: umlproperty["Constraint", Sequence["Constraint"]]
    submachine: umlproperty["StateMachine", Sequence["StateMachine"]]
    redefinedState: umlproperty["State", Sequence["State"]]


class FinalState(State):
    pass


class Port(Property):
    isBehavior: umlproperty[int, int]
    isService: umlproperty[int, int]


class Deployment(Dependency):
    deployedArtifact: umlproperty["DeployedArtifact", Sequence["DeployedArtifact"]]


class ActivityPartition(ActivityGroup, NamedElement):
    isDimension: umlproperty[int, int]
    isExternal: umlproperty[int, int]
    node: umlproperty["ActivityNode", Sequence["ActivityNode"]]
    represents: umlproperty["Element", Sequence["Element"]]
    subpartition: umlproperty["ActivityPartition", Sequence["ActivityPartition"]]


class MessageOccurrenceSpecification(MessageEnd, OccurrenceSpecification):
    pass


class AcceptEventAction(Action):
    isUnmarshall: umlproperty[int, int]
    result: umlproperty["OutputPin", Sequence["OutputPin"]]


class ReplyAction(Action):
    replyValue: umlproperty["InputPin", Sequence["InputPin"]]
    returnInformation: umlproperty["InputPin", Sequence["InputPin"]]


class UnmarshallAction(Action):
    result: umlproperty["OutputPin", Sequence["OutputPin"]]
    unmarshallType: umlproperty["Classifier", Sequence["Classifier"]]
    object: umlproperty["InputPin", Sequence["InputPin"]]


class AcceptCallAction(AcceptEventAction):
    returnInformation: umlproperty["OutputPin", Sequence["OutputPin"]]


class InvocationAction(Action):
    pass


class SendSignalAction(InvocationAction):
    target: umlproperty["InputPin", Sequence["InputPin"]]


class Collaboration(StructuredClassifier, BehavioredClassifier):
    collaborationRole: umlproperty["ConnectableElement", Sequence["ConnectableElement"]]


class Trigger(NamedElement):
    event: umlproperty["Event", Sequence["Event"]]


class Event(PackageableElement):
    pass


class ExecutionEvent(Event):
    pass


class CreationEvent(Event):
    pass


class MessageEvent(Event):
    pass


class DestructionEvent(Event):
    pass


class SendOperationEvent(MessageEvent):
    operation: umlproperty["Operation", Sequence["Operation"]]


class SendSignalEvent(MessageEvent):
    signal: umlproperty["Signal", Sequence["Signal"]]


class ReceiveOperationEvent(MessageEvent):
    operation: umlproperty["Operation", Sequence["Operation"]]


class ReceiveSignalEvent(MessageEvent):
    signal: umlproperty["Signal", Sequence["Signal"]]


class Signal(Classifier):
    ownedAttribute: umlproperty["Property", Sequence["Property"]]


class Reception(BehavioralFeature):
    signal: umlproperty["Signal", Sequence["Signal"]]


# class 'ValueSpecification' has been stereotyped as 'SimpleAttribute'
# class 'InstanceValue' has been stereotyped as 'SimpleAttribute' too
# class 'Expression' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralSpecification' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralUnlimitedNatural' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralBoolean' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralInteger' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralString' has been stereotyped as 'SimpleAttribute' too
# class 'LiteralNull' has been stereotyped as 'SimpleAttribute' too
# class 'OpaqueExpression' has been stereotyped as 'SimpleAttribute' too
Extension.isRequired = attribute("isRequired", int)
Feature.isStatic = attribute("isStatic", int, default=False)
RedefinableElement.isLeaf = attribute("isLeaf", int, default=True)
Generalization.isSubstitutable = attribute("isSubstitutable", int)
ObjectNode.ordering = enumeration(
    "ordering", ("unordered", "ordered", "LIFO", "FIFO"), "FIFO"
)
ObjectNode.isControlType = attribute("isControlType", int, default=False)
StructuralFeature.isReadOnly = attribute("isReadOnly", int, default=False)
NamedElement.visibility = enumeration(
    "visibility", ("public", "private", "package", "protected"), "public"
)
NamedElement.name = attribute("name", str)
# 41: override NamedElement.qualifiedName


def namedelement_qualifiedname(self):
    """
    Returns the qualified name of the element as a tuple
    """
    if self.namespace:
        return self.namespace.qualifiedName + (self.name,)
    else:
        return (self.name,)


NamedElement.qualifiedName = property(
    namedelement_qualifiedname, doc=namedelement_qualifiedname.__doc__
)

del namedelement_qualifiedname

Component.isIndirectlyInstantiated = attribute(
    "isIndirectlyInstantiated", int, default=True
)
Association.isDerived = attribute("isDerived", int, default=False)
PackageableElement.visibility = enumeration(
    "visibility", ("public", "private", "package", "protected"), "public"
)
ElementImport.visibility = enumeration(
    "visibility", ("public", "private", "package", "protected"), "public"
)
ElementImport.alias = attribute("alias", str)
MultiplicityElement.isUnique = attribute("isUnique", int, default=True)
MultiplicityElement.isOrdered = attribute("isOrdered", int, default=True)
Activity.body = attribute("body", str)
Activity.language = attribute("language", str)
Classifier.isAbstract = attribute("isAbstract", int, default=False)
Parameter.direction = enumeration("direction", ("inout", "in", "out", "return"), "in")
Operation.isQuery = attribute("isQuery", int, default=False)
Property.aggregation = enumeration(
    "aggregation", ("none", "shared", "composite"), "none"
)
Property.isDerivedUnion = attribute("isDerivedUnion", int, default=False)
Property.isDerived = attribute("isDerived", int, default=False)
Property.isReadOnly = attribute("isReadOnly", int, default=False)
# 143: override Property.navigability


def property_navigability(self):
    """
    Get navigability of an association end.
    If no association is related to the property, then unknown navigability
    is assumed.
    """
    assoc = self.association
    if not assoc or not self.opposite:
        return None  # assume unknown
    owner = self.opposite.type
    if owner and (
        (type(self.type) in (Class, Interface) and self in owner.ownedAttribute)
        or self in assoc.navigableOwnedEnd
    ):
        return True
    elif self in assoc.ownedEnd:
        return None
    else:
        return False


Property.navigability = property(
    property_navigability, doc=property_navigability.__doc__
)

del property_navigability

Behavior.isReentrant = attribute("isReentrant", int)
BehavioralFeature.isAbstract = attribute("isAbstract", int)
Action.effect = attribute("effect", str)
Comment.body = attribute("body", str)
PackageImport.visibility = enumeration(
    "visibility", ("public", "private", "package", "protected"), "public"
)
# 248: override Message.messageKind


def message_messageKind(self):
    kind = "unknown"
    if self.sendEvent:
        kind = "lost"
        if self.receiveEvent:
            kind = "complete"
    elif self.receiveEvent:
        kind = "found"
    return kind


Message.messageKind = property(
    message_messageKind,
    doc="""
    MessageKind
    """,
)
del message_messageKind


Message.messageSort = enumeration(
    "messageSort",
    (
        "synchCall",
        "asynchCall",
        "asynchSignal",
        "createMessage",
        "deleteMessage",
        "reply",
    ),
    "synchCall",
)
Connector.kind = enumeration("kind", ("assembly", "delegation"), "assembly")
JoinNode.isCombineDuplicate = attribute("isCombineDuplicate", int, default=True)
Transition.kind = enumeration("kind", ("internal", "local", "external"), "internal")
Pseudostate.kind = enumeration(
    "kind",
    (
        "initial",
        "deepHistory",
        "shallowHistory",
        "join",
        "fork",
        "junction",
        "choice",
        "entryPoint",
        "exitPoint",
        "terminate",
    ),
    "initial",
)
Port.isBehavior = attribute("isBehavior", int)
Port.isService = attribute("isService", int)
ActivityPartition.isDimension = attribute("isDimension", int, default=False)
ActivityPartition.isExternal = attribute("isExternal", int, default=False)
AcceptEventAction.isUnmarshall = attribute("isUnmarshall", int, default=False)
Operation.precondition = association("precondition", Constraint, composite=True)
Package.ownedDiagram = association(
    "ownedDiagram", Diagram, composite=True, opposite="package"
)
Diagram.package = association("package", Package, upper=1, opposite="ownedDiagram")
Package.nestedPackage = association(
    "nestedPackage", Package, composite=True, opposite="package"
)
Package.package = association("package", Package, upper=1, opposite="nestedPackage")
NamedElement.clientDependency = association(
    "clientDependency", Dependency, opposite="client"
)
Dependency.client = association(
    "client", NamedElement, lower=1, opposite="clientDependency"
)
DecisionNode.decisionInput = association("decisionInput", Behavior, upper=1)
Activity.edge = association("edge", ActivityEdge, composite=True, opposite="activity")
ActivityEdge.activity = association("activity", Activity, upper=1, opposite="edge")
Substitution.contract = association("contract", Classifier, lower=1, upper=1)
Operation.bodyCondition = association(
    "bodyCondition", Constraint, upper=1, composite=True
)
# 'InstanceSpecification.specification' is a simple attribute
InstanceSpecification.specification = attribute("specification", str)
BehavioralFeature.method = association("method", Behavior)
Property.datatype = association(
    "datatype", DataType, upper=1, opposite="ownedAttribute"
)
DataType.ownedAttribute = association(
    "ownedAttribute", Property, composite=True, opposite="datatype"
)
TypedElement.type = association("type", Type, upper=1)
Element.presentation = association(
    "presentation", Presentation, composite=True, opposite="subject"
)
Presentation.subject = association("subject", Element, upper=1, opposite="presentation")
ActivityParameterNode.parameter = association("parameter", Parameter, lower=1, upper=1)
Dependency.supplier = association(
    "supplier", NamedElement, lower=1, opposite="supplierDependency"
)
NamedElement.supplierDependency = association(
    "supplierDependency", Dependency, opposite="supplier"
)
Operation.redefinedOperation = association("redefinedOperation", Operation)
Activity.group = association(
    "group", ActivityGroup, composite=True, opposite="activity"
)
ActivityGroup.activity = association("activity", Activity, upper=1, opposite="group")
Package.ownedClassifier = association(
    "ownedClassifier", Type, composite=True, opposite="package"
)
Type.package = association("package", Package, upper=1, opposite="ownedClassifier")
Property.subsettedProperty = association("subsettedProperty", Property)
Property.classifier = association(
    "classifier", Classifier, upper=1, opposite="attribute"
)
ExtensionEnd.type = association("type", Stereotype, lower=1, upper=1)
Profile.metamodelReference = association(
    "metamodelReference", PackageImport, composite=True
)
# 'ActivityEdge.guard' is a simple attribute
ActivityEdge.guard = attribute("guard", str)
Class.ownedOperation = association(
    "ownedOperation", Operation, composite=True, opposite="class_"
)
Operation.class_ = association("class_", Class, upper=1, opposite="ownedOperation")
Enumeration.literal = association(
    "literal", EnumerationLiteral, composite=True, opposite="enumeration"
)
EnumerationLiteral.enumeration = association(
    "enumeration", Enumeration, upper=1, opposite="literal"
)
ActivityEdge.source = association(
    "source", ActivityNode, lower=1, upper=1, opposite="outgoing"
)
ActivityNode.outgoing = association("outgoing", ActivityEdge, opposite="source")
Profile.ownedStereotype = association("ownedStereotype", Stereotype, composite=True)
Property.redefinedProperty = association("redefinedProperty", Property)
DataType.ownedOperation = association(
    "ownedOperation", Operation, composite=True, opposite="datatype"
)
Operation.datatype = association(
    "datatype", DataType, upper=1, opposite="ownedOperation"
)
Generalization.general = association("general", Classifier, lower=1, upper=1)
Classifier.ownedUseCase = association("ownedUseCase", UseCase, composite=True)
# 'MultiplicityElement.upperValue' is a simple attribute
MultiplicityElement.upperValue = attribute("upperValue", str)
PackageMerge.mergingPackage = association(
    "mergingPackage", Package, lower=1, upper=1, opposite="packageExtension"
)
Package.packageExtension = association(
    "packageExtension", PackageMerge, composite=True, opposite="mergingPackage"
)
Package.appliedProfile = association(
    "appliedProfile", ProfileApplication, composite=True
)
Activity.node = association("node", ActivityNode, composite=True)
# 'Parameter.defaultValue' is a simple attribute
Parameter.defaultValue = attribute("defaultValue", str)
Class.nestedClassifier = association("nestedClassifier", Classifier, composite=True)
# 'Slot.value' is a simple attribute
Slot.value = attribute("value", str)
Include.addition = association("addition", UseCase, lower=1, upper=1)
Realization.realizingClassifier = association(
    "realizingClassifier", Classifier, lower=1, upper=1
)
# 'TypedElement.typeValue' is a simple attribute
TypedElement.typeValue = attribute("typeValue", str)
Constraint.constrainedElement = association("constrainedElement", Element)
PackageMerge.mergedPackage = association("mergedPackage", Package, lower=1, upper=1)
BehavioralFeature.formalParameter = association(
    "formalParameter", Parameter, composite=True, opposite="ownerFormalParam"
)
Parameter.ownerFormalParam = association(
    "ownerFormalParam", BehavioralFeature, upper=1, opposite="formalParameter"
)
Class.ownedAttribute = association(
    "ownedAttribute", Property, composite=True, opposite="class_"
)
Property.class_ = association("class_", Class, upper=1, opposite="ownedAttribute")
Extend.extendedCase = association("extendedCase", UseCase, lower=1, upper=1)
# 'Property.defaultValue' is a simple attribute
Property.defaultValue = attribute("defaultValue", str)
Namespace.ownedRule = association("ownedRule", Constraint, composite=True)
Property.association = association(
    "association", Association, upper=1, opposite="memberEnd"
)
Association.memberEnd = association(
    "memberEnd", Property, lower=2, composite=True, opposite="association"
)
Classifier.generalization = association(
    "generalization", Generalization, composite=True, opposite="specific"
)
Generalization.specific = association(
    "specific", Classifier, lower=1, upper=1, opposite="generalization"
)
Realization.abstraction = association(
    "abstraction", Component, upper=1, opposite="realization"
)
Component.realization = association(
    "realization", Realization, composite=True, opposite="abstraction"
)
# 'ValuePin.value_' is a simple attribute
ValuePin.value_ = attribute("value_", str)
BehavioralFeature.raisedException = association("raisedException", Type)
Activity.action = association("action", Action, composite=True)
# 'Abstraction.mapping' is a simple attribute
Abstraction.mapping = attribute("mapping", str)
ActivityNode.incoming = association("incoming", ActivityEdge, opposite="target")
ActivityEdge.target = association(
    "target", ActivityNode, lower=1, upper=1, opposite="incoming"
)
Extend.extensionLocation = association("extensionLocation", ExtensionPoint, lower=1)
Property.interface_ = association(
    "interface_", Interface, upper=1, opposite="ownedAttribute"
)
Interface.ownedAttribute = association(
    "ownedAttribute", Property, composite=True, opposite="interface_"
)
ActivityGroup.edgeContents = association(
    "edgeContents", ActivityEdge, opposite="inGroup"
)
ActivityEdge.inGroup = association("inGroup", ActivityGroup, opposite="edgeContents")
Slot.owningInstance = association(
    "owningInstance", InstanceSpecification, lower=1, upper=1, opposite="slot"
)
InstanceSpecification.slot = association(
    "slot", Slot, composite=True, opposite="owningInstance"
)
UseCase.subject = association("subject", Classifier)
Property.owningAssociation = association(
    "owningAssociation", Association, upper=1, opposite="ownedEnd"
)
Association.ownedEnd = association(
    "ownedEnd", Property, composite=True, opposite="owningAssociation"
)
Interface.redefinedInterface = association("redefinedInterface", Interface)
Artifact.manifestation = association("manifestation", Manifestation, composite=True)
ExtensionPoint.useCase = association(
    "useCase", UseCase, lower=1, upper=1, opposite="extensionPoint"
)
UseCase.extensionPoint = association(
    "extensionPoint", ExtensionPoint, opposite="useCase"
)
Operation.postcondition = association("postcondition", Constraint, composite=True)
Extension.ownedEnd = association(
    "ownedEnd", ExtensionEnd, lower=1, upper=1, composite=True
)
# 'Constraint.specification' is a simple attribute
Constraint.specification = attribute("specification", str)
Profile.metaclassReference = association(
    "metaclassReference", ElementImport, composite=True
)
Namespace.elementImport = association(
    "elementImport", ElementImport, composite=True, opposite="importingNamespace"
)
ElementImport.importingNamespace = association(
    "importingNamespace", Namespace, upper=1, opposite="elementImport"
)
# 'MultiplicityElement.lowerValue' is a simple attribute
MultiplicityElement.lowerValue = attribute("lowerValue", str)
Interface.nestedInterface = association("nestedInterface", Interface, composite=True)
InstanceSpecification.classifier = association("classifier", Classifier)
Interface.ownedOperation = association(
    "ownedOperation", Operation, composite=True, opposite="interface_"
)
Operation.interface_ = association(
    "interface_", Interface, upper=1, opposite="ownedOperation"
)
ElementImport.importedElement = association(
    "importedElement", PackageableElement, lower=1, upper=1
)
Parameter.ownerReturnParam = association(
    "ownerReturnParam", BehavioralFeature, upper=1, opposite="returnResult"
)
BehavioralFeature.returnResult = association(
    "returnResult", Parameter, composite=True, opposite="ownerReturnParam"
)
Classifier.redefinedClassifier = association("redefinedClassifier", Classifier)
Substitution.substitutingClassifier = association(
    "substitutingClassifier", Classifier, lower=1, upper=1, opposite="substitution"
)
Classifier.substitution = association(
    "substitution", Substitution, composite=True, opposite="substitutingClassifier"
)
Operation.raisedException = association("raisedException", Type)
PackageImport.importedPackage = association(
    "importedPackage", Package, lower=1, upper=1
)
StructuralFeature.slot = association(
    "slot", Slot, composite=True, opposite="definingFeature"
)
Slot.definingFeature = association(
    "definingFeature", StructuralFeature, lower=1, upper=1, opposite="slot"
)
Include.includingCase = association(
    "includingCase", UseCase, lower=1, upper=1, opposite="include"
)
UseCase.include = association(
    "include", Include, composite=True, opposite="includingCase"
)
Extend.extension = association(
    "extension", UseCase, lower=1, upper=1, opposite="extend"
)
UseCase.extend = association("extend", Extend, composite=True, opposite="extension")
Extend.constraint = association("constraint", Constraint, upper=1, composite=True)
ProfileApplication.importedProfile = association(
    "importedProfile", Profile, lower=1, upper=1
)
Namespace.packageImport = association(
    "packageImport", PackageImport, composite=True, opposite="importingNamespace"
)
PackageImport.importingNamespace = association(
    "importingNamespace", Namespace, upper=1, opposite="packageImport"
)
Behavior.redefinedBehavior = association("redefinedBehavior", Behavior)
Element.ownedComment = association("ownedComment", Comment, opposite="annotatedElement")
Comment.annotatedElement = association(
    "annotatedElement", Element, opposite="ownedComment"
)
Behavior.context = association(
    "context", BehavioredClassifier, upper=1, opposite="ownedBehavior"
)
BehavioredClassifier.ownedBehavior = association(
    "ownedBehavior", Behavior, composite=True, opposite="context"
)
ActivityGroup.nodeContents = association(
    "nodeContents", ActivityNode, opposite="inGroup"
)
ActivityNode.inGroup = association("inGroup", ActivityGroup, opposite="nodeContents")
UseCase.ownedAttribute = association(
    "ownedAttribute", Property, composite=True, opposite="useCase"
)
Property.useCase = association("useCase", UseCase, upper=1, opposite="ownedAttribute")
Property.actor = association("actor", Actor, upper=1, opposite="ownedAttribute")
Actor.ownedAttribute = association(
    "ownedAttribute", Property, composite=True, opposite="actor"
)
InteractionFragment.enclosingInteraction = association(
    "enclosingInteraction", Interaction, upper=1, opposite="fragment"
)
Interaction.fragment = association(
    "fragment", InteractionFragment, opposite="enclosingInteraction"
)
StateInvariant.invariant = association(
    "invariant", Constraint, lower=1, upper=1, composite=True
)
Lifeline.coveredBy = association("coveredBy", InteractionFragment, opposite="covered")
InteractionFragment.covered = association(
    "covered", Lifeline, lower=1, upper=1, opposite="coveredBy"
)
Lifeline.interaction = association(
    "interaction", Interaction, lower=1, upper=1, opposite="lifeline"
)
Interaction.lifeline = association(
    "lifeline", Lifeline, composite=True, opposite="interaction"
)
# 'Lifeline.discriminator' is a simple attribute
Lifeline.discriminator = attribute("discriminator", str)
# 'Message.argument' is a simple attribute
Message.argument = attribute("argument", str)
Message.signature = association("signature", NamedElement, upper=1)
MessageEnd.sendMessage = association(
    "sendMessage", Message, upper=1, opposite="sendEvent"
)
Message.sendEvent = association(
    "sendEvent", MessageEnd, upper=1, composite=True, opposite="sendMessage"
)
MessageEnd.receiveMessage = association(
    "receiveMessage", Message, upper=1, opposite="receiveEvent"
)
Message.receiveEvent = association(
    "receiveEvent", MessageEnd, upper=1, composite=True, opposite="receiveMessage"
)
Message.interaction = association(
    "interaction", Interaction, lower=1, upper=1, opposite="message"
)
Interaction.message = association(
    "message", Message, composite=True, opposite="interaction"
)
InteractionFragment.generalOrdering = association(
    "generalOrdering", GeneralOrdering, composite=True
)
GeneralOrdering.before = association(
    "before", OccurrenceSpecification, lower=1, upper=1, opposite="toAfter"
)
OccurrenceSpecification.toAfter = association(
    "toAfter", GeneralOrdering, opposite="before"
)
GeneralOrdering.after = association(
    "after", OccurrenceSpecification, lower=1, upper=1, opposite="toBefore"
)
OccurrenceSpecification.toBefore = association(
    "toBefore", GeneralOrdering, opposite="after"
)
ExecutionOccurence.finish = association(
    "finish", OccurrenceSpecification, lower=1, upper=1, opposite="finishExec"
)
OccurrenceSpecification.finishExec = association(
    "finishExec", ExecutionOccurence, opposite="finish"
)
ExecutionOccurence.start = association(
    "start", OccurrenceSpecification, lower=1, upper=1, opposite="startExec"
)
OccurrenceSpecification.startExec = association(
    "startExec", ExecutionOccurence, opposite="start"
)
ExecutionOccurence.behavior = association("behavior", Behavior)
StructuredClassifier.ownedConnector = association(
    "ownedConnector", Connector, composite=True
)
Connector.redefinedConnector = association("redefinedConnector", Connector)
Connector.type = association("type", Association, upper=1)
Connector.end = association("end", ConnectorEnd, lower=2, composite=True)
Connector.contract = association("contract", Behavior)
ConnectorEnd.role = association("role", ConnectableElement, upper=1, opposite="end")
ConnectableElement.end = association("end", ConnectorEnd, opposite="role")
StructuredClassifier.ownedAttribute = association(
    "ownedAttribute", Property, composite=True
)
# 'ObjectNode.upperBound' is a simple attribute
ObjectNode.upperBound = attribute("upperBound", str)
ObjectNode.selection = association("selection", Behavior, upper=1)
# 'JoinNode.joinSpec' is a simple attribute
JoinNode.joinSpec = attribute("joinSpec", str)
StateMachine.region = association(
    "region", Region, lower=1, composite=True, opposite="stateMachine"
)
Region.stateMachine = association(
    "stateMachine", StateMachine, upper=1, opposite="region"
)
Transition.container = association("container", Region, lower=1, upper=1)
Region.subvertex = association(
    "subvertex", Vertex, composite=True, opposite="container"
)
Vertex.container = association("container", Region, upper=1, opposite="subvertex")
Transition.source = association("source", Vertex, lower=1, upper=1, opposite="outgoing")
Vertex.outgoing = association("outgoing", Transition, opposite="source")
Transition.target = association("target", Vertex, lower=1, upper=1, opposite="incoming")
Vertex.incoming = association("incoming", Transition, opposite="target")
ConnectionPointReference.entry = association("entry", Pseudostate)
ConnectionPointReference.exit = association("exit", Pseudostate)
Pseudostate.stateMachine = association("stateMachine", StateMachine, upper=1)
Region.state = association("state", State, upper=1)
Pseudostate.state = association("state", State, upper=1)
ConnectionPointReference.state = association("state", State, upper=1)
State.entry = association("entry", Behavior, upper=1, composite=True)
State.exit = association("exit", Behavior, upper=1, composite=True)
State.doActivity = association("doActivity", Behavior, upper=1, composite=True)
Transition.effect = association("effect", Behavior, upper=1, composite=True)
State.statevariant = association(
    "statevariant", Constraint, upper=1, composite=True, opposite="owningState"
)
Constraint.owningState = association(
    "owningState", State, upper=1, opposite="statevariant"
)
Transition.guard = association("guard", Constraint, upper=1, composite=True)
State.submachine = association("submachine", StateMachine, upper=1)
StateMachine.extendedStateMachine = association(
    "extendedStateMachine", StateMachine, upper=1
)
ConnectorEnd.partWithPort = association("partWithPort", Property, upper=1)
EncapsulatedClassifer.ownedPort = association("ownedPort", Port, composite=True)
Element.appliedStereotype = association(
    "appliedStereotype", InstanceSpecification, opposite="extended"
)
InstanceSpecification.extended = association(
    "extended", Element, opposite="appliedStereotype"
)
Node.nestedNode = association("nestedNode", Node, composite=True)
DeploymentTarget.deployment = association("deployment", Deployment, composite=True)
Deployment.deployedArtifact = association("deployedArtifact", DeployedArtifact)
ActivityNode.inPartition = association(
    "inPartition", ActivityPartition, opposite="node"
)
ActivityPartition.node = association("node", ActivityNode, opposite="inPartition")
ActivityPartition.represents = association("represents", Element, upper=1)
ActivityPartition.subpartition = association("subpartition", ActivityPartition)
Association.navigableOwnedEnd = association("navigableOwnedEnd", Property)
AcceptEventAction.result = association("result", OutputPin, composite=True)
UnmarshallAction.result = association("result", OutputPin, composite=True)
AcceptCallAction.returnInformation = association(
    "returnInformation", OutputPin, lower=1, upper=1, composite=True
)
UnmarshallAction.unmarshallType = association(
    "unmarshallType", Classifier, lower=1, upper=1
)
UnmarshallAction.object = association(
    "object", InputPin, lower=1, upper=1, composite=True
)
ReplyAction.replyValue = association("replyValue", InputPin, upper=1, composite=True)
ReplyAction.returnInformation = association(
    "returnInformation", InputPin, lower=1, upper=1, composite=True
)
SendSignalAction.target = association("target", InputPin, composite=True)
Collaboration.collaborationRole = association("collaborationRole", ConnectableElement)
BehavioredClassifier.ownedTrigger = association("ownedTrigger", Trigger, composite=True)
Trigger.event = association("event", Event, lower=1, upper=1)
Signal.ownedAttribute = association("ownedAttribute", Property, composite=True)
Reception.signal = association("signal", Signal, upper=1)
Class.ownedReception = association("ownedReception", Reception, composite=True)
Interface.ownedReception = association("ownedReception", Reception, composite=True)
SendOperationEvent.operation = association("operation", Operation, lower=1, upper=1)
SendSignalEvent.signal = association("signal", Signal, lower=1, upper=1)
ReceiveOperationEvent.operation = association("operation", Operation, lower=1, upper=1)
ReceiveSignalEvent.signal = association("signal", Signal, lower=1, upper=1)
# 35: override MultiplicityElement.lower derives MultiplicityElement.lowerValue
MultiplicityElement.lower = derived(
    "lower", object, 0, 1, lambda obj: [obj.lowerValue], MultiplicityElement.lowerValue
)

# 38: override MultiplicityElement.upper derives MultiplicityElement.upperValue
MultiplicityElement.upper = derived(
    "upper", object, 0, 1, lambda obj: [obj.upperValue], MultiplicityElement.upperValue
)

# 135: override Property.isComposite derives Property.aggregation
# Property.isComposite = property(lambda self: self.aggregation == 'composite')
Property.isComposite = derivedunion("isComposite", bool, 0, 1, Property.aggregation)
Property.isComposite.filter = lambda obj: [obj.aggregation == "composite"]

RedefinableElement.redefinedElement = derivedunion(
    "redefinedElement",
    RedefinableElement,
    0,
    "*",
    Property.redefinedProperty,
    Classifier.redefinedClassifier,
    Operation.redefinedOperation,
    Interface.redefinedInterface,
    Behavior.redefinedBehavior,
    Connector.redefinedConnector,
)
Classifier.attribute = derivedunion(
    "attribute",
    Property,
    0,
    "*",
    Class.ownedAttribute,
    DataType.ownedAttribute,
    Interface.ownedAttribute,
    UseCase.ownedAttribute,
    Actor.ownedAttribute,
    Signal.ownedAttribute,
)
Classifier.feature = derivedunion(
    "feature",
    Feature,
    0,
    "*",
    Interface.ownedOperation,
    UseCase.extensionPoint,
    DataType.ownedOperation,
    Class.ownedOperation,
    Association.ownedEnd,
    Classifier.attribute,
    StructuredClassifier.ownedConnector,
    Class.ownedReception,
    Interface.ownedReception,
)
Feature.featuringClassifier = derivedunion(
    "featuringClassifier",
    Classifier,
    1,
    "*",
    Property.class_,
    Property.owningAssociation,
    Operation.class_,
    Operation.datatype,
    Property.datatype,
    Operation.interface_,
)
# 114: override Property.opposite


def property_opposite(self):
    """
    In the case where the property is one navigable end of a binary
    association with both ends navigable, this gives the other end.

    For Gaphor the property on the other end is returned regardless the
    navigability.
    """
    if self.association is not None and len(self.association.memberEnd) == 2:
        return (
            self.association.memberEnd[0] is self
            and self.association.memberEnd[1]
            or self.association.memberEnd[0]
        )
    return None


Property.opposite = property(property_opposite, doc=property_opposite.__doc__)

del property_opposite


BehavioralFeature.parameter = derivedunion(
    "parameter",
    Parameter,
    0,
    "*",
    BehavioralFeature.returnResult,
    BehavioralFeature.formalParameter,
)
Action.output = derivedunion("output", OutputPin, 0, "*")
Transition.redefintionContext = derivedunion("redefintionContext", Classifier, 1, 1)
RedefinableElement.redefinitionContext = derivedunion(
    "redefinitionContext",
    Classifier,
    0,
    "*",
    Operation.class_,
    Property.classifier,
    Operation.datatype,
    Transition.redefintionContext,
)
NamedElement.namespace = derivedunion(
    "namespace",
    Namespace,
    0,
    1,
    Parameter.ownerReturnParam,
    Property.interface_,
    Property.class_,
    Property.owningAssociation,
    Operation.class_,
    EnumerationLiteral.enumeration,
    Diagram.package,
    Operation.datatype,
    Type.package,
    Property.datatype,
    Operation.interface_,
    Package.package,
    Parameter.ownerFormalParam,
    Property.useCase,
    Property.actor,
    Lifeline.interaction,
    Message.interaction,
    Region.stateMachine,
    Transition.container,
    Vertex.container,
    Pseudostate.stateMachine,
    Region.state,
    ConnectionPointReference.state,
)
Namespace.ownedMember = derivedunion(
    "ownedMember",
    NamedElement,
    0,
    "*",
    Interface.ownedOperation,
    Enumeration.literal,
    Package.ownedDiagram,
    Namespace.ownedRule,
    UseCase.extensionPoint,
    DataType.ownedOperation,
    Operation.precondition,
    BehavioralFeature.returnResult,
    Profile.ownedStereotype,
    Class.nestedClassifier,
    Class.ownedAttribute,
    BehavioralFeature.formalParameter,
    Classifier.ownedUseCase,
    DataType.ownedAttribute,
    Class.ownedOperation,
    Operation.postcondition,
    Association.ownedEnd,
    Package.ownedClassifier,
    Interface.ownedAttribute,
    Operation.bodyCondition,
    Extend.constraint,
    Package.nestedPackage,
    BehavioredClassifier.ownedBehavior,
    UseCase.ownedAttribute,
    Actor.ownedAttribute,
    StateInvariant.invariant,
    Interaction.lifeline,
    Interaction.message,
    StateMachine.region,
    Region.subvertex,
    Node.nestedNode,
    BehavioredClassifier.ownedTrigger,
    Signal.ownedAttribute,
    Class.ownedReception,
    Interface.ownedReception,
)
# 99: override Classifier.general
def classifier_general(self):
    return [g.general for g in self.generalization]


Classifier.general = property(
    classifier_general,
    doc="""
    Return a list of all superclasses for class (iterating the Generalizations.
    """,
)
del classifier_general

# 56: override Association.endType derives Association.memberEnd Property.type

# References the classifiers that are used as types of the ends of the
# association.

Association.endType = derived(
    "endType",
    Type,
    0,
    "*",
    lambda self: [end.type for end in self.memberEnd if end],
    Association.memberEnd,
    Property.type,
)


# 140: override Constraint.context
Constraint.context = derivedunion("context", Namespace, 0, 1)

# 168: override Operation.type
Operation.type = derivedunion("type", DataType, 0, 1)

# 79: override Extension.metaclass derives Extension.ownedEnd Association.memberEnd
# See https://www.omg.org/spec/UML/2.5/PDF, section 12.4.1.5, page 271
def extension_metaclass(self):
    ownedEnd = self.ownedEnd
    metaend = [e for e in self.memberEnd if e is not ownedEnd]
    if metaend:
        return metaend[0].type


# Don't use derived() now, it can not deal with a [0..1] property derived from a [0..*] property.
# Extension.metaclass = derived('metaclass', Class, 0, 1, Extension.ownedEnd, Association.memberEnd)
# Extension.metaclass.filter = extension_metaclass
Extension.metaclass = property(
    extension_metaclass,
    doc="""References the Class that is extended through an Extension. The
property is derived from the type of the memberEnd that is not the
ownedEnd.""",
)
del extension_metaclass

# 64: override Class.extension derives Extension.metaclass
# See https://www.omg.org/spec/UML/2.5/PDF, section 11.8.3.6, page 219
# It defines `Extension.allInstances()`, which basically means we have to query the element factory.
def class_extension(self):
    return list(
        self.model.select(lambda e: e.isKindOf(Extension) and self is e.metaclass)
    )


# TODO: use those as soon as Extension.metaclass can be used.
# Class.extension = derived('extension', Extension, 0, '*', class_extension, Extension.metaclass)

Class.extension = property(
    class_extension,
    doc="""References the Extensions that specify additional properties of the
metaclass. The property is derived from the extensions whose memberEnds
are typed by the Class.""",
)
del class_extension

DirectedRelationship.target = derivedunion(
    "target",
    Element,
    1,
    "*",
    PackageImport.importedPackage,
    PackageMerge.mergedPackage,
    Generalization.general,
    Include.addition,
    Extend.extendedCase,
    Realization.realizingClassifier,
    ElementImport.importedElement,
    Substitution.contract,
)
DirectedRelationship.source = derivedunion(
    "source",
    Element,
    1,
    "*",
    Extend.extension,
    Realization.abstraction,
    Substitution.substitutingClassifier,
    Include.includingCase,
    ElementImport.importingNamespace,
    Generalization.specific,
    PackageImport.importingNamespace,
    PackageMerge.mergingPackage,
)
Action.context_ = derivedunion("context_", Classifier, 0, 1)
Relationship.relatedElement = derivedunion(
    "relatedElement",
    Element,
    1,
    "*",
    DirectedRelationship.target,
    DirectedRelationship.source,
)
ActivityGroup.superGroup = derivedunion("superGroup", ActivityGroup, 0, 1)
ActivityGroup.subgroup = derivedunion(
    "subgroup", ActivityGroup, 0, "*", ActivityPartition.subpartition
)
# 96: override Classifier.inheritedMember
Classifier.inheritedMember = derivedunion("inheritedMember", NamedElement, 0, "*")

StructuredClassifier.role = derivedunion(
    "role",
    ConnectableElement,
    0,
    "*",
    StructuredClassifier.ownedAttribute,
    Collaboration.collaborationRole,
)
Namespace.member = derivedunion(
    "member",
    NamedElement,
    0,
    "*",
    BehavioralFeature.parameter,
    Namespace.ownedMember,
    Association.memberEnd,
    Classifier.inheritedMember,
    StructuredClassifier.role,
)
# 233: override Component.required
def component_required(self):
    usages = _pr_interface_deps(self, Usage)

    # realizing classifiers usages
    # this generator of generators, so flatten it later
    rc_usages = _pr_rc_interface_deps(self, Usage)

    return tuple(set(itertools.chain(usages, *rc_usages)))


Component.required = property(
    component_required,
    doc="""
    Interfaces required by component.
    """,
)
del component_required

# 111: override Namespace.importedMember
Namespace.importedMember = derivedunion("importedMember", PackageableElement, 0, "*")

Action.input = derivedunion("input", InputPin, 0, "*", SendSignalAction.target)
# 197: override Component.provided
import itertools


def _pr_interface_deps(classifier, dep_type):
    """
    Return all interfaces, which are connected to a classifier with given
    dependency type.
    """
    return (
        dep.supplier[0]
        for dep in classifier.clientDependency
        if dep.isKindOf(dep_type) and dep.supplier[0].isKindOf(Interface)
    )


def _pr_rc_interface_deps(component, dep_type):
    """
    Return all interfaces, which are connected to realizing classifiers of
    specified component. Returned interfaces are connected to realizing
    classifiers with given dependency type.

    Generator of generators is returned. Do not forget to flat it later.
    """
    return (
        _pr_interface_deps(r.realizingClassifier, dep_type)
        for r in component.realization
    )


def component_provided(self):
    implementations = (
        impl.contract[0]
        for impl in self.implementation
        if impl.isKindOf(Implementation)
    )
    realizations = _pr_interface_deps(self, Realization)

    # realizing classifiers realizations
    # this generator of generators, so flatten it later
    rc_realizations = _pr_rc_interface_deps(self, Realization)

    return tuple(set(itertools.chain(implementations, realizations, *rc_realizations)))


Component.provided = property(
    component_provided,
    doc="""
    Interfaces provided to component environment.
    """,
)
del component_provided

Element.owner = derivedunion(
    "owner",
    Element,
    0,
    1,
    Slot.owningInstance,
    Realization.abstraction,
    ElementImport.importingNamespace,
    Generalization.specific,
    ActivityEdge.activity,
    ActivityGroup.superGroup,
    ActivityGroup.activity,
    PackageImport.importingNamespace,
    PackageMerge.mergingPackage,
    NamedElement.namespace,
    Pseudostate.state,
)
Element.ownedElement = derivedunion(
    "ownedElement",
    Element,
    0,
    "*",
    Artifact.manifestation,
    Element.ownedComment,
    Action.input,
    Classifier.generalization,
    Namespace.ownedMember,
    Namespace.elementImport,
    Activity.group,
    Component.realization,
    Namespace.packageImport,
    Package.packageExtension,
    Substitution.contract,
    ActivityGroup.subgroup,
    Activity.edge,
    Activity.node,
    Action.output,
    Interaction.fragment,
    InteractionFragment.generalOrdering,
    Connector.end,
    State.entry,
    State.exit,
    State.doActivity,
    Transition.effect,
    State.statevariant,
    Transition.guard,
    DeploymentTarget.deployment,
)
ConnectorEnd.definingEnd = derivedunion("definingEnd", Property, 0, 1)
# 267: override StructuredClassifier.part
def structuredclassifier_part(self):
    return tuple(a for a in self.ownedAttribute if a.isComposite)


StructuredClassifier.part = property(
    structuredclassifier_part,
    doc="""
    Properties owned by a classifier by composition.
""",
)
del structuredclassifier_part

# 108: override Class.superClass
Class.superClass = Classifier.general

ActivityNode.redefinedElement = redefine(
    ActivityNode, "redefinedElement", ActivityNode, RedefinableElement.redefinedElement
)
Implementation.contract = redefine(
    Implementation, "contract", Interface, Dependency.supplier
)
BehavioredClassifier.implementation = redefine(
    BehavioredClassifier,
    "implementation",
    Implementation,
    NamedElement.clientDependency,
)
Implementation.implementatingClassifier = redefine(
    Implementation, "implementatingClassifier", BehavioredClassifier, Dependency.client
)
Parameter.operation = redefine(
    Parameter, "operation", Operation, Parameter.ownerFormalParam
)
Operation.formalParameter = redefine(
    Operation, "formalParameter", Parameter, BehavioralFeature.formalParameter
)
ActivityEdge.redefinedElement = redefine(
    ActivityEdge, "redefinedElement", ActivityEdge, RedefinableElement.redefinedElement
)
Package.ownedMember = redefine(
    Package, "ownedMember", PackageableElement, Namespace.ownedMember
)
Component.ownedMember = redefine(
    Component, "ownedMember", PackageableElement, Namespace.ownedMember
)
Region.extendedRegion = redefine(
    Region, "extendedRegion", Region, RedefinableElement.redefinedElement
)
State.redefinedState = redefine(
    State, "redefinedState", State, RedefinableElement.redefinedElement
)
Transition.redefinedTransition = redefine(
    Transition, "redefinedTransition", Transition, RedefinableElement.redefinedElement
)
# 171: override Lifeline.parse
from gaphor.UML.umllex import parse_lifeline

Lifeline.parse = parse_lifeline
del parse_lifeline

# 176: override Lifeline.render
from gaphor.UML.umllex import render_lifeline

Lifeline.render = render_lifeline
del render_lifeline
