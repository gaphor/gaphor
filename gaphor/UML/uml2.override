comment
  vim:sw=4:et:syntax=python

  This is a file with custom definitions for Gaphors data model.

  Parts are separated by '%%' (no training spaces) on a line.
  Comment parts start with 'comment' on the line belowe the percentage
  symbols, 'override' is used to define a overridden variable. 

%%
override Element
from element import Element
%%
override Diagram
from diagram import Diagram
%%
override MultiplicityElement.lower
# Make it watch MultiplicityElement.lowerValue.value
def _get(self):
    return self.lowerValue and self.lowerValue.value
def _set(self, value):
    if not self.lowerValue:
        self.lowerValue = self._factory.create(LiteralString)
    self.lowerValue.value = value
def _del(self):
    if self.lowerValue:
        del self.lowerValue.value

MultiplicityElement.lower = property(_get, _set, _del)
del _get, _set, _del
# TODO: let it also emit notifications
# A notifier should be connected on instantiation of the lowerValue element.
# - this should be done on creation of the lowerValue, hence we should
#   add a notifier when self.lowerValue changes.
# - This requires some extra code to be executed on creation of our
#   MultiplicityElement. This can be done either in the Element or the
#   ElementFactory.
%%
override MultiplicityElement.upper
# Make it watch MultiplicityElement.upperValue.value
def _get(self):
    return self.upperValue and self.upperValue.value
def _set(self, value):
    if not self.upperValue:
        self.upperValue = self._factory.create(LiteralString)
    self.upperValue.value = value
def _del(self):
    if self.upperValue:
        del self.upperValue.value

MultiplicityElement.upper = property(_get, _set, _del)
del _get, _set, _del
%%
override Classifier.inheritedMember
Classifier.inheritedMember = derivedunion('inheritedMember', 0, '*')
%%
override Classifier.general
Classifier.general = derivedunion('inheritedMember', 0, '*')
%%
override Namespace.importedMember
Namespace.importedMember = derivedunion('importedMember', 0, '*')
%%
override Property.opposite

def property_opposite(self):
    """In the case where the property is one navigable end of a binary
    association with both ends navigable, this gives the other end.

    For Gaphor the property on the other end is returned regardless the
    navigability.
    """
    #if not self.owningAssociation and len(self.association.memberEnd) == 2:
    #    other_end = self.association.memberEnd[0] is self \
    #                and self.association.memberEnd[1] \
    #                or self.association.memberEnd[0]
    #    return other_end
    if len(self.association.memberEnd) == 2:
        return self.association.memberEnd[0] is self \
               and self.association.memberEnd[1] \
               or self.association.memberEnd[0]
    return None

Property.opposite = property(property_opposite, doc=property_opposite.__doc__)

del property_opposite
%%
override Property.isComposite
Property.isComposite = property(lambda self: self.aggregation == intern('composite'))
%%
override Constraint.context
Constraint.context = derivedunion('context', 0, 1)
%%
override Association.endType
Association.endType = derivedunion('endType', 1, '*')
%%
override Operation.type
Operation.type = derivedunion('type', 0, 1)
%%
override Property.parse
from umllex import parse_property
Property.parse = parse_property
del parse_property
%%
override Property.render
from umllex import render_property
Property.render = render_property
del render_property
%%
override Operation.parse
from umllex import parse_operation
Operation.parse = parse_operation
del parse_operation
%%
override Operation.render
from umllex import render_operation
Operation.render = render_operation
del render_operation
