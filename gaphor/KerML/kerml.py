# This file is generated by coder.py. DO NOT EDIT!
# ruff: noqa: F401, E402, F811
# fmt: off

from __future__ import annotations

import enum

from gaphor.core.modeling.properties import (
    association,
    attribute as _attribute,
    derived,
    derivedunion,
    enumeration as _enumeration,
    redefine,
    relation_many,
    relation_one,
)




from gaphor.core.modeling.base import Base as _Base


class FeatureDirectionKind(enum.StrEnum):
    in_ = "in"
    inout = "inout"
    out = "out"


class VisibilityKind(enum.StrEnum):
    private = "private"
    protected = "protected"
    public = "public"


class Element(_Base):
    aliasIds: _attribute[str] = _attribute("aliasIds", str)
    declaredName: _attribute[str] = _attribute("declaredName", str)
    declaredShortName: _attribute[str] = _attribute("declaredShortName", str)
    documentation: relation_many[Documentation]
    elementId: _attribute[str] = _attribute("elementId", str)
    isImpliedIncluded: _attribute[bool] = _attribute("isImpliedIncluded", bool, default=False)
    ownedAnnotation: relation_many[Annotation]
    ownedElement: derived[Element]
    ownedRelationship: relation_many[Relationship]
    owner: derived[Element]
    owningMembership: relation_one[OwningMembership]
    owningNamespace: relation_one[Namespace]
    owningRelationship: relation_one[Relationship]
    textualRepresentation: relation_many[TextualRepresentation]


class Namespace(Element):
    importedMembership: relation_many[Membership]
    member: relation_many[Element]
    membership: relation_many[Membership]
    ownedImport: relation_many[Import]
    ownedMember: relation_many[Element]
    ownedMembership: relation_many[Membership]


class Type(Namespace):
    differencingType: relation_many[Type]
    directedFeature: relation_many[Feature]
    endFeature: relation_many[Feature]
    feature: relation_many[Feature]
    featureMembership: relation_many[FeatureMembership]
    inheritedFeature: relation_many[Feature]
    inheritedMembership: relation_many[Membership]
    input: relation_many[Feature]
    intersectingType: relation_many[Type]
    isAbstract: _attribute[bool] = _attribute("isAbstract", bool, default=False)
    isSufficient: _attribute[bool] = _attribute("isSufficient", bool, default=False)
    multiplicity: relation_one[Multiplicity]
    output: relation_many[Feature]
    ownedConjugator: relation_one[Conjugation]
    ownedDifferencing: relation_many[Differencing]
    ownedDisjoining: relation_many[Disjoining]
    ownedEndFeature: relation_many[Feature]
    ownedFeature: relation_many[Feature]
    ownedFeatureMembership: relation_many[FeatureMembership]
    ownedIntersecting: relation_many[Intersecting]
    ownedSpecialization: relation_many[Specialization]
    ownedUnioning: relation_many[Unioning]
    unioningType: relation_many[Type]


class Classifier(Type):
    ownedSubclassification: relation_many[Subclassification]


class Class(Classifier):
    pass


class Behavior(Class):
    parameter: relation_many[Feature]
    step: relation_many[Step]


class Relationship(Element):
    isImplied: _attribute[bool] = _attribute("isImplied", bool, default=False)
    ownedRelatedElement: relation_many[Element]
    owningRelatedElement: relation_one[Element]
    relatedElement: relation_many[Element]
    source: relation_many[Element]
    target: relation_many[Element]


class Membership(Relationship):
    memberElement: relation_one[Element]
    memberName: _attribute[str] = _attribute("memberName", str)
    memberShortName: _attribute[str] = _attribute("memberShortName", str)
    membershipOwningNamespace: relation_one[Namespace]
    visibility = _enumeration("visibility", VisibilityKind, VisibilityKind.private)


class OwningMembership(Membership):
    ownedMemberElement: relation_one[Element]


class FeatureMembership(OwningMembership):
    ownedMemberFeature: relation_one[Feature]
    owningType: relation_one[Type]


class ParameterMembership(FeatureMembership):
    ownedMemberParameter: relation_one[Feature]


class Feature(Type):
    chainingFeature: relation_many[Feature]
    crossFeature: relation_one[Feature]
    direction = _enumeration("direction", FeatureDirectionKind, FeatureDirectionKind.in_)
    endOwningType: relation_one[Type]
    featureTarget: relation_one[Feature]
    featuringType: relation_many[Type]
    isComposite: _attribute[bool] = _attribute("isComposite", bool, default=False)
    isConstant: _attribute[bool] = _attribute("isConstant", bool, default=False)
    isDerived: _attribute[bool] = _attribute("isDerived", bool, default=False)
    isEnd: _attribute[bool] = _attribute("isEnd", bool, default=False)
    isOrdered: _attribute[bool] = _attribute("isOrdered", bool, default=False)
    isPortion: _attribute[bool] = _attribute("isPortion", bool, default=False)
    isUnique: _attribute[bool] = _attribute("isUnique", bool, default=False)
    isVariable: _attribute[bool] = _attribute("isVariable", bool, default=False)
    ownedCrossSubsetting: relation_one[CrossSubsetting]
    ownedFeatureChaining: relation_many[FeatureChaining]
    ownedFeatureInverting: relation_many[FeatureInverting]
    ownedRedefinition: relation_many[Redefinition]
    ownedReferenceSubsetting: relation_one[ReferenceSubsetting]
    ownedSubsetting: relation_many[Subsetting]
    ownedTypeFeaturing: relation_many[TypeFeaturing]
    ownedTyping: relation_many[FeatureTyping]
    owningFeatureMembership: relation_one[FeatureMembership]
    owningType: relation_one[Type]
    type: relation_many[Type]


class Step(Feature):
    behavior: relation_many[Behavior]
    parameter: relation_many[Feature]


class Expression(Step):
    function: relation_one[Function]
    result: relation_one[Feature]


class InstantiationExpression(Expression):
    argument: relation_many[Expression]
    instantiatedType: relation_one[Type]


class InvocationExpression(InstantiationExpression):
    pass


class OperatorExpression(InvocationExpression):
    operator: _attribute[str] = _attribute("operator", str)


class FeatureChainExpression(OperatorExpression):
    operator: _attribute[str] = _attribute("operator", str, default=None)
    targetFeature: relation_one[Feature]


class LiteralExpression(Expression):
    pass


class LiteralString(LiteralExpression):
    value: _attribute[str] = _attribute("value", str)


class LiteralInteger(LiteralExpression):
    value: _attribute[int] = _attribute("value", int)


class MetadataAccessExpression(Expression):
    referencedElement: relation_one[Element]


class ConstructorExpression(InstantiationExpression):
    pass


class LiteralRational(LiteralExpression):
    value: _attribute[int] = _attribute("value", int)


class LiteralBoolean(LiteralExpression):
    value: _attribute[bool] = _attribute("value", bool)


class LiteralInfinity(LiteralExpression):
    pass


class NullExpression(Expression):
    pass


class SelectExpression(OperatorExpression):
    operator: _attribute[str] = _attribute("operator", str, default=None)


class FeatureReferenceExpression(Expression):
    referent: relation_one[Feature]


class CollectExpression(OperatorExpression):
    operator: _attribute[str] = _attribute("operator", str, default=None)


class IndexExpression(OperatorExpression):
    operator: _attribute[str] = _attribute("operator", str, default=None)


class ReturnParameterMembership(ParameterMembership):
    pass


class Function(Behavior):
    expression: relation_many[Expression]
    result: relation_one[Feature]


class Predicate(Function):
    pass


class ResultExpressionMembership(FeatureMembership):
    ownedResultExpression: relation_one[Expression]


class BooleanExpression(Expression):
    predicate: relation_one[Predicate]


class Invariant(BooleanExpression):
    isNegated: _attribute[bool] = _attribute("isNegated", bool, default=False)


class Connector(Feature, Relationship):
    association: relation_many[Association]
    connectorEnd: relation_many[Feature]
    defaultFeaturingType: relation_one[Type]
    relatedFeature: relation_many[Feature]
    sourceFeature: relation_one[Feature]
    targetFeature: relation_many[Feature]


class Flow(Connector, Step):
    flowEnd: relation_many[FlowEnd]
    interaction: relation_many[Interaction]
    payloadFeature: relation_one[PayloadFeature]
    payloadType: relation_many[Classifier]
    sourceOutputFeature: relation_one[Feature]
    targetInputFeature: relation_one[Feature]


class Succession(Connector):
    pass


class SuccessionFlow(Flow, Succession):
    pass


class PayloadFeature(Feature):
    pass


class FlowEnd(Feature):
    pass


class Association(Classifier, Relationship):
    associationEnd: relation_many[Feature]
    relatedType: relation_many[Type]
    sourceType: relation_one[Type]
    targetType: relation_many[Type]


class Interaction(Association, Behavior):
    pass


class FeatureValue(OwningMembership):
    featureWithValue: relation_one[Feature]
    isDefault: _attribute[bool] = _attribute("isDefault", bool, default=False)
    isInitial: _attribute[bool] = _attribute("isInitial", bool, default=False)
    value: relation_one[Expression]


class ElementFilterMembership(OwningMembership):
    condition: relation_one[Expression]


class Package(Namespace):
    filterCondition: relation_many[Expression]


class LibraryPackage(Package):
    isStandard: _attribute[bool] = _attribute("isStandard", bool, default=False)


class Multiplicity(Feature):
    pass


class MultiplicityRange(Multiplicity):
    bound: relation_many[Expression]
    lowerBound: relation_one[Expression]
    upperBound: relation_one[Expression]


class BindingConnector(Connector):
    pass


class Structure(Class):
    pass


class Metaclass(Structure):
    pass


class AnnotatingElement(Element):
    annotatedElement: relation_many[Element]
    annotation: relation_many[Annotation]
    ownedAnnotatingRelationship: relation_many[Annotation]
    owningAnnotatingRelationship: relation_one[Annotation]


class MetadataFeature(AnnotatingElement, Feature):
    metaclass: relation_one[Metaclass]


class AssociationStructure(Association, Structure):
    pass


class DataType(Classifier):
    pass


class Disjoining(Relationship):
    disjoiningType: relation_one[Type]
    owningType: relation_one[Type]
    typeDisjoined: relation_one[Type]


class Differencing(Relationship):
    differencingType: relation_one[Type]
    typeDifferenced: relation_one[Type]


class Intersecting(Relationship):
    intersectingType: relation_one[Type]
    typeIntersected: relation_one[Type]


class Unioning(Relationship):
    typeUnioned: relation_one[Type]
    unioningType: relation_one[Type]


class Conjugation(Relationship):
    conjugatedType: relation_one[Type]
    originalType: relation_one[Type]
    owningType: relation_one[Type]


class Specialization(Relationship):
    general: relation_one[Type]
    owningType: relation_one[Type]
    specific: relation_one[Type]


class Subclassification(Specialization):
    owningClassifier: relation_one[Classifier]
    subclassifier: relation_one[Classifier]
    superclassifier: relation_one[Classifier]


class FeatureInverting(Relationship):
    featureInverted: relation_one[Feature]
    invertingFeature: relation_one[Feature]
    owningFeature: relation_one[Feature]


class FeatureChaining(Relationship):
    chainingFeature: relation_one[Feature]
    featureChained: relation_one[Feature]


class Subsetting(Specialization):
    owningFeature: relation_one[Feature]
    subsettedFeature: relation_one[Feature]
    subsettingFeature: relation_one[Feature]


class Redefinition(Subsetting):
    redefinedFeature: relation_one[Feature]
    redefiningFeature: relation_one[Feature]


class ReferenceSubsetting(Subsetting):
    referencedFeature: relation_one[Feature]
    referencingFeature: relation_one[Feature]


class TypeFeaturing(Relationship):
    featureOfType: relation_one[Feature]
    featuringType: relation_one[Type]
    owningFeatureOfType: relation_one[Feature]


class FeatureTyping(Specialization):
    owningFeature: relation_one[Feature]
    type: relation_one[Type]
    typedFeature: relation_one[Feature]


class EndFeatureMembership(FeatureMembership):
    ownedMemberFeature: relation_one[Feature]  # type: ignore[assignment]


class CrossSubsetting(Subsetting):
    crossedFeature: relation_one[Feature]
    crossingFeature: relation_one[Feature]


class Dependency(Relationship):
    client: relation_many[Element]
    supplier: relation_many[Element]


class TextualRepresentation(AnnotatingElement):
    body: _attribute[str] = _attribute("body", str)
    language: _attribute[str] = _attribute("language", str)
    representedElement: relation_one[Element]


class Comment(AnnotatingElement):
    body: _attribute[str] = _attribute("body", str)
    locale: _attribute[str] = _attribute("locale", str)


class Documentation(Comment):
    documentedElement: relation_one[Element]


class Annotation(Relationship):
    annotatedElement: relation_one[Element]
    annotatingElement: relation_one[AnnotatingElement]
    ownedAnnotatingElement: relation_one[AnnotatingElement]
    owningAnnotatedElement: relation_one[Element]
    owningAnnotatingElement: relation_one[AnnotatingElement]


class Import(Relationship):
    importOwningNamespace: relation_one[Namespace]
    importedElement: relation_one[Element]
    isImportAll: _attribute[bool] = _attribute("isImportAll", bool, default=False)
    isRecursive: _attribute[bool] = _attribute("isRecursive", bool, default=False)
    visibility = _enumeration("visibility", VisibilityKind, VisibilityKind.private)


class NamespaceImport(Import):
    importedNamespace: relation_one[Namespace]


class MembershipImport(Import):
    importedMembership: relation_one[Membership]



Element.owningMembership = derivedunion("owningMembership", OwningMembership, upper=1)
Element.owningRelationship = association("owningRelationship", Relationship, upper=1, opposite="ownedRelatedElement")
Element.owningNamespace = derivedunion("owningNamespace", Namespace, upper=1)
Element.ownedRelationship = association("ownedRelationship", Relationship, opposite="owningRelatedElement")
# 17: override Element.owner: derived[Element]

Element.owner = derived("owner", Element, 0, 1,
    lambda e: e.owningRelationship and [e.owningRelationship.owningRelatedElement] or [None])

# 22: override Element.ownedElement: derived[Element]

Element.ownedElement = derived("ownedElement", Element, 0, "*",
    lambda e: e.ownedRelationship and e.ownedRelationship[:].ownedRelatedElement)

Element.documentation = derivedunion("documentation", Documentation)
Element.ownedAnnotation = derivedunion("ownedAnnotation", Annotation)
Element.textualRepresentation = derivedunion("textualRepresentation", TextualRepresentation)
Element.owningRelationship.add(Element.owningMembership)  # type: ignore[attr-defined]
Element.ownedElement.add(Element.documentation)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Element.ownedAnnotation)  # type: ignore[attr-defined]
Element.ownedElement.add(Element.textualRepresentation)  # type: ignore[attr-defined]
Namespace.membership = derivedunion("membership", Membership)
Namespace.ownedImport = derivedunion("ownedImport", Import)
Namespace.member = derivedunion("member", Element)
Namespace.ownedMember = derivedunion("ownedMember", Element)
Namespace.ownedMembership = derivedunion("ownedMembership", Membership)
Namespace.importedMembership = derivedunion("importedMembership", Membership)
Element.ownedRelationship.add(Namespace.ownedImport)  # type: ignore[attr-defined]
Namespace.member.add(Namespace.ownedMember)  # type: ignore[attr-defined]
Namespace.membership.add(Namespace.ownedMembership)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Namespace.ownedMembership)  # type: ignore[attr-defined]
Namespace.membership.add(Namespace.importedMembership)  # type: ignore[attr-defined]
Type.ownedSpecialization = derivedunion("ownedSpecialization", Specialization)
Type.ownedFeatureMembership = derivedunion("ownedFeatureMembership", FeatureMembership)
Type.feature = derivedunion("feature", Feature)
Type.ownedFeature = derivedunion("ownedFeature", Feature)
Type.input = derivedunion("input", Feature)
Type.output = derivedunion("output", Feature)
Type.inheritedMembership = derivedunion("inheritedMembership", Membership)
Type.endFeature = derivedunion("endFeature", Feature)
Type.ownedEndFeature = derivedunion("ownedEndFeature", Feature)
Type.ownedConjugator = derivedunion("ownedConjugator", Conjugation, upper=1)
Type.inheritedFeature = derivedunion("inheritedFeature", Feature)
Type.multiplicity = derivedunion("multiplicity", Multiplicity, upper=1)
Type.unioningType = derivedunion("unioningType", Type)
Type.ownedIntersecting = derivedunion("ownedIntersecting", Intersecting)
Type.intersectingType = derivedunion("intersectingType", Type)
Type.ownedUnioning = derivedunion("ownedUnioning", Unioning)
Type.ownedDisjoining = derivedunion("ownedDisjoining", Disjoining)
Type.featureMembership = derivedunion("featureMembership", FeatureMembership)
Type.differencingType = derivedunion("differencingType", Type)
Type.ownedDifferencing = derivedunion("ownedDifferencing", Differencing)
Type.directedFeature = derivedunion("directedFeature", Feature)
Element.ownedRelationship.add(Type.ownedSpecialization)  # type: ignore[attr-defined]
Namespace.ownedMembership.add(Type.ownedFeatureMembership)  # type: ignore[attr-defined]
Type.featureMembership.add(Type.ownedFeatureMembership)  # type: ignore[attr-defined]
Namespace.member.add(Type.feature)  # type: ignore[attr-defined]
Namespace.ownedMember.add(Type.ownedFeature)  # type: ignore[attr-defined]
Type.directedFeature.add(Type.input)  # type: ignore[attr-defined]
Type.directedFeature.add(Type.output)  # type: ignore[attr-defined]
Namespace.membership.add(Type.inheritedMembership)  # type: ignore[attr-defined]
Type.feature.add(Type.endFeature)  # type: ignore[attr-defined]
Type.endFeature.add(Type.ownedEndFeature)  # type: ignore[attr-defined]
Type.ownedFeature.add(Type.ownedEndFeature)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Type.ownedConjugator)  # type: ignore[attr-defined]
Type.feature.add(Type.inheritedFeature)  # type: ignore[attr-defined]
Namespace.ownedMember.add(Type.multiplicity)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Type.ownedIntersecting)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Type.ownedUnioning)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Type.ownedDisjoining)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Type.ownedDifferencing)  # type: ignore[attr-defined]
Type.feature.add(Type.directedFeature)  # type: ignore[attr-defined]
Classifier.ownedSubclassification = derivedunion("ownedSubclassification", Subclassification)
Type.ownedSpecialization.add(Classifier.ownedSubclassification)  # type: ignore[attr-defined]
Behavior.step = derivedunion("step", Step)
Behavior.parameter = redefine(Behavior, "parameter", Feature, Type.directedFeature)
Type.feature.add(Behavior.step)  # type: ignore[attr-defined]
Relationship.relatedElement = derivedunion("relatedElement", Element)
Relationship.target = association("target", Element)
Relationship.source = association("source", Element)
Relationship.owningRelatedElement = association("owningRelatedElement", Element, upper=1, opposite="ownedRelationship")
Relationship.ownedRelatedElement = association("ownedRelatedElement", Element, opposite="owningRelationship")
Relationship.relatedElement.add(Relationship.target)  # type: ignore[attr-defined]
Relationship.relatedElement.add(Relationship.source)  # type: ignore[attr-defined]
Relationship.relatedElement.add(Relationship.owningRelatedElement)  # type: ignore[attr-defined]
Relationship.relatedElement.add(Relationship.ownedRelatedElement)  # type: ignore[attr-defined]
Membership.membershipOwningNamespace = redefine(Membership, "membershipOwningNamespace", Namespace, Relationship.source, opposite="ownedMembership")
Membership.memberElement = redefine(Membership, "memberElement", Element, Relationship.target)
Relationship.owningRelatedElement.add(Membership.membershipOwningNamespace)  # type: ignore[attr-defined]
OwningMembership.ownedMemberElement = redefine(OwningMembership, "ownedMemberElement", Element, Membership.memberElement, opposite="owningMembership")
Relationship.ownedRelatedElement.add(OwningMembership.ownedMemberElement)  # type: ignore[attr-defined]
FeatureMembership.owningType = redefine(FeatureMembership, "owningType", Type, Membership.membershipOwningNamespace, opposite="ownedFeatureMembership")
FeatureMembership.ownedMemberFeature = redefine(FeatureMembership, "ownedMemberFeature", Feature, OwningMembership.ownedMemberElement, opposite="owningFeatureMembership")
ParameterMembership.ownedMemberParameter = redefine(ParameterMembership, "ownedMemberParameter", Feature, FeatureMembership.ownedMemberFeature)
Feature.owningType = derivedunion("owningType", Type, upper=1)
Feature.type = derivedunion("type", Type)
Feature.ownedRedefinition = derivedunion("ownedRedefinition", Redefinition)
Feature.ownedSubsetting = derivedunion("ownedSubsetting", Subsetting)
Feature.owningFeatureMembership = derivedunion("owningFeatureMembership", FeatureMembership, upper=1)
Feature.endOwningType = derivedunion("endOwningType", Type, upper=1)
Feature.ownedTyping = derivedunion("ownedTyping", FeatureTyping)
Feature.featuringType = derivedunion("featuringType", Type)
Feature.ownedTypeFeaturing = derivedunion("ownedTypeFeaturing", TypeFeaturing)
Feature.chainingFeature = derivedunion("chainingFeature", Feature)
Feature.ownedFeatureInverting = derivedunion("ownedFeatureInverting", FeatureInverting)
Feature.ownedFeatureChaining = derivedunion("ownedFeatureChaining", FeatureChaining)
Feature.ownedReferenceSubsetting = derivedunion("ownedReferenceSubsetting", ReferenceSubsetting, upper=1)
Feature.featureTarget = derivedunion("featureTarget", Feature, lower=1, upper=1)
Feature.crossFeature = derivedunion("crossFeature", Feature, upper=1)
Feature.ownedCrossSubsetting = derivedunion("ownedCrossSubsetting", CrossSubsetting, upper=1)
Feature.featuringType.add(Feature.owningType)  # type: ignore[attr-defined]
Element.owningNamespace.add(Feature.owningType)  # type: ignore[attr-defined]
Feature.ownedSubsetting.add(Feature.ownedRedefinition)  # type: ignore[attr-defined]
Type.ownedSpecialization.add(Feature.ownedSubsetting)  # type: ignore[attr-defined]
Element.owningMembership.add(Feature.owningFeatureMembership)  # type: ignore[attr-defined]
Feature.owningType.add(Feature.endOwningType)  # type: ignore[attr-defined]
Type.ownedSpecialization.add(Feature.ownedTyping)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Feature.ownedTypeFeaturing)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Feature.ownedFeatureInverting)  # type: ignore[attr-defined]
Element.ownedRelationship.add(Feature.ownedFeatureChaining)  # type: ignore[attr-defined]
Feature.ownedSubsetting.add(Feature.ownedReferenceSubsetting)  # type: ignore[attr-defined]
Feature.ownedSubsetting.add(Feature.ownedCrossSubsetting)  # type: ignore[attr-defined]
Step.behavior = derivedunion("behavior", Behavior)
Step.parameter = redefine(Step, "parameter", Feature, Type.directedFeature)
Feature.type.add(Step.behavior)  # type: ignore[attr-defined]
Expression.result = derivedunion("result", Feature, lower=1, upper=1)
Expression.function = redefine(Expression, "function", Function, Step.behavior)
Type.output.add(Expression.result)  # type: ignore[attr-defined]
Step.parameter.add(Expression.result)  # type: ignore[attr-defined]
InstantiationExpression.argument = derivedunion("argument", Expression)
InstantiationExpression.instantiatedType = derivedunion("instantiatedType", Type, lower=1, upper=1)
Namespace.member.add(InstantiationExpression.instantiatedType)  # type: ignore[attr-defined]
FeatureChainExpression.targetFeature = derivedunion("targetFeature", Feature, lower=1, upper=1)
Namespace.member.add(FeatureChainExpression.targetFeature)  # type: ignore[attr-defined]
MetadataAccessExpression.referencedElement = derivedunion("referencedElement", Element, lower=1, upper=1)
Namespace.member.add(MetadataAccessExpression.referencedElement)  # type: ignore[attr-defined]
FeatureReferenceExpression.referent = derivedunion("referent", Feature, lower=1, upper=1)
Namespace.member.add(FeatureReferenceExpression.referent)  # type: ignore[attr-defined]
Function.expression = derivedunion("expression", Expression)
Function.result = derivedunion("result", Feature, lower=1, upper=1)
Behavior.step.add(Function.expression)  # type: ignore[attr-defined]
Type.output.add(Function.result)  # type: ignore[attr-defined]
Behavior.parameter.add(Function.result)  # type: ignore[attr-defined]
ResultExpressionMembership.ownedResultExpression = redefine(ResultExpressionMembership, "ownedResultExpression", Expression, FeatureMembership.ownedMemberFeature)
BooleanExpression.predicate = redefine(BooleanExpression, "predicate", Predicate, Expression.function)
Connector.defaultFeaturingType = derivedunion("defaultFeaturingType", Type, upper=1)
Connector.relatedFeature = redefine(Connector, "relatedFeature", Feature, Relationship.relatedElement)
Connector.association = redefine(Connector, "association", Association, Feature.type)
Connector.connectorEnd = redefine(Connector, "connectorEnd", Feature, Type.endFeature)
Connector.sourceFeature = redefine(Connector, "sourceFeature", Feature, Relationship.source)
Connector.targetFeature = redefine(Connector, "targetFeature", Feature, Relationship.target)
Connector.relatedFeature.add(Connector.sourceFeature)  # type: ignore[attr-defined]
Connector.relatedFeature.add(Connector.targetFeature)  # type: ignore[attr-defined]
Flow.payloadType = derivedunion("payloadType", Classifier)
Flow.targetInputFeature = derivedunion("targetInputFeature", Feature, upper=1)
Flow.sourceOutputFeature = derivedunion("sourceOutputFeature", Feature, upper=1)
Flow.flowEnd = derivedunion("flowEnd", FlowEnd, upper=2)
Flow.payloadFeature = derivedunion("payloadFeature", PayloadFeature, upper=1)
Flow.interaction = redefine(Flow, "interaction", Interaction, Connector.association)
Connector.connectorEnd.add(Flow.flowEnd)  # type: ignore[attr-defined]
Type.ownedFeature.add(Flow.payloadFeature)  # type: ignore[attr-defined]
Association.relatedType = redefine(Association, "relatedType", Type, Relationship.relatedElement)
Association.sourceType = redefine(Association, "sourceType", Type, Relationship.source)
Association.targetType = redefine(Association, "targetType", Type, Relationship.target)
Association.associationEnd = redefine(Association, "associationEnd", Feature, Type.endFeature)
Association.relatedType.add(Association.sourceType)  # type: ignore[attr-defined]
Association.relatedType.add(Association.targetType)  # type: ignore[attr-defined]
FeatureValue.featureWithValue = derivedunion("featureWithValue", Feature, lower=1, upper=1)
FeatureValue.value = redefine(FeatureValue, "value", Expression, OwningMembership.ownedMemberElement)
Membership.membershipOwningNamespace.add(FeatureValue.featureWithValue)  # type: ignore[attr-defined]
ElementFilterMembership.condition = redefine(ElementFilterMembership, "condition", Expression, OwningMembership.ownedMemberElement)
Package.filterCondition = derivedunion("filterCondition", Expression)
Namespace.ownedMember.add(Package.filterCondition)  # type: ignore[attr-defined]
MultiplicityRange.lowerBound = derivedunion("lowerBound", Expression, upper=1)
MultiplicityRange.upperBound = derivedunion("upperBound", Expression, lower=1, upper=1)
MultiplicityRange.bound = derivedunion("bound", Expression, lower=1, upper=2)
MultiplicityRange.bound.add(MultiplicityRange.lowerBound)  # type: ignore[attr-defined]
MultiplicityRange.bound.add(MultiplicityRange.upperBound)  # type: ignore[attr-defined]
Namespace.ownedMember.add(MultiplicityRange.bound)  # type: ignore[attr-defined]
AnnotatingElement.annotatedElement = derivedunion("annotatedElement", Element, lower=1)
AnnotatingElement.ownedAnnotatingRelationship = derivedunion("ownedAnnotatingRelationship", Annotation)
AnnotatingElement.owningAnnotatingRelationship = derivedunion("owningAnnotatingRelationship", Annotation, upper=1)
AnnotatingElement.annotation = derivedunion("annotation", Annotation)
AnnotatingElement.annotation.add(AnnotatingElement.ownedAnnotatingRelationship)  # type: ignore[attr-defined]
Element.ownedRelationship.add(AnnotatingElement.ownedAnnotatingRelationship)  # type: ignore[attr-defined]
Element.owningRelationship.add(AnnotatingElement.owningAnnotatingRelationship)  # type: ignore[attr-defined]
AnnotatingElement.annotation.add(AnnotatingElement.owningAnnotatingRelationship)  # type: ignore[attr-defined]
MetadataFeature.metaclass = derivedunion("metaclass", Metaclass, upper=1)
Feature.type.add(MetadataFeature.metaclass)  # type: ignore[attr-defined]
Disjoining.owningType = derivedunion("owningType", Type, upper=1)
Disjoining.typeDisjoined = redefine(Disjoining, "typeDisjoined", Type, Relationship.source)
Disjoining.disjoiningType = redefine(Disjoining, "disjoiningType", Type, Relationship.target)
Relationship.owningRelatedElement.add(Disjoining.owningType)  # type: ignore[attr-defined]
Disjoining.typeDisjoined.add(Disjoining.owningType)  # type: ignore[attr-defined]
Differencing.typeDifferenced = redefine(Differencing, "typeDifferenced", Type, Relationship.source, opposite="ownedDifferencing")
Differencing.differencingType = redefine(Differencing, "differencingType", Type, Relationship.target)
Relationship.owningRelatedElement.add(Differencing.typeDifferenced)  # type: ignore[attr-defined]
Intersecting.typeIntersected = redefine(Intersecting, "typeIntersected", Type, Relationship.source, opposite="ownedIntersecting")
Intersecting.intersectingType = redefine(Intersecting, "intersectingType", Type, Relationship.target)
Relationship.owningRelatedElement.add(Intersecting.typeIntersected)  # type: ignore[attr-defined]
Unioning.typeUnioned = redefine(Unioning, "typeUnioned", Type, Relationship.source, opposite="ownedUnioning")
Unioning.unioningType = redefine(Unioning, "unioningType", Type, Relationship.target)
Relationship.owningRelatedElement.add(Unioning.typeUnioned)  # type: ignore[attr-defined]
Conjugation.owningType = derivedunion("owningType", Type, upper=1)
Conjugation.originalType = redefine(Conjugation, "originalType", Type, Relationship.target)
Conjugation.conjugatedType = redefine(Conjugation, "conjugatedType", Type, Relationship.source)
Conjugation.conjugatedType.add(Conjugation.owningType)  # type: ignore[attr-defined]
Relationship.owningRelatedElement.add(Conjugation.owningType)  # type: ignore[attr-defined]
Specialization.owningType = derivedunion("owningType", Type, upper=1)
Specialization.general = redefine(Specialization, "general", Type, Relationship.target)
Specialization.specific = redefine(Specialization, "specific", Type, Relationship.source)
Relationship.owningRelatedElement.add(Specialization.owningType)  # type: ignore[attr-defined]
Specialization.specific.add(Specialization.owningType)  # type: ignore[attr-defined]
Subclassification.superclassifier = redefine(Subclassification, "superclassifier", Classifier, Specialization.general)
Subclassification.subclassifier = redefine(Subclassification, "subclassifier", Classifier, Specialization.specific)
Subclassification.owningClassifier = redefine(Subclassification, "owningClassifier", Classifier, Specialization.owningType, opposite="ownedSubclassification")
FeatureInverting.owningFeature = derivedunion("owningFeature", Feature, upper=1)
FeatureInverting.featureInverted = redefine(FeatureInverting, "featureInverted", Feature, Relationship.source)
FeatureInverting.invertingFeature = redefine(FeatureInverting, "invertingFeature", Feature, Relationship.target)
FeatureInverting.featureInverted.add(FeatureInverting.owningFeature)  # type: ignore[attr-defined]
Relationship.owningRelatedElement.add(FeatureInverting.owningFeature)  # type: ignore[attr-defined]
FeatureChaining.chainingFeature = redefine(FeatureChaining, "chainingFeature", Feature, Relationship.target)
FeatureChaining.featureChained = redefine(FeatureChaining, "featureChained", Feature, Relationship.source, opposite="ownedFeatureChaining")
Relationship.owningRelatedElement.add(FeatureChaining.featureChained)  # type: ignore[attr-defined]
Subsetting.subsettedFeature = redefine(Subsetting, "subsettedFeature", Feature, Specialization.general)
Subsetting.subsettingFeature = redefine(Subsetting, "subsettingFeature", Feature, Specialization.specific)
Subsetting.owningFeature = redefine(Subsetting, "owningFeature", Feature, Specialization.owningType, opposite="ownedSubsetting")
Subsetting.subsettingFeature.add(Subsetting.owningFeature)  # type: ignore[attr-defined]
Redefinition.redefiningFeature = redefine(Redefinition, "redefiningFeature", Feature, Subsetting.subsettingFeature)
Redefinition.redefinedFeature = redefine(Redefinition, "redefinedFeature", Feature, Subsetting.subsettedFeature)
ReferenceSubsetting.referencedFeature = redefine(ReferenceSubsetting, "referencedFeature", Feature, Subsetting.subsettedFeature)
ReferenceSubsetting.referencingFeature = redefine(ReferenceSubsetting, "referencingFeature", Feature, Subsetting.owningFeature, opposite="ownedReferenceSubsetting")
TypeFeaturing.owningFeatureOfType = derivedunion("owningFeatureOfType", Feature, upper=1)
TypeFeaturing.featureOfType = redefine(TypeFeaturing, "featureOfType", Feature, Relationship.source)
TypeFeaturing.featuringType = redefine(TypeFeaturing, "featuringType", Type, Relationship.target)
Relationship.owningRelatedElement.add(TypeFeaturing.owningFeatureOfType)  # type: ignore[attr-defined]
TypeFeaturing.featureOfType.add(TypeFeaturing.owningFeatureOfType)  # type: ignore[attr-defined]
FeatureTyping.typedFeature = redefine(FeatureTyping, "typedFeature", Feature, Specialization.specific)
FeatureTyping.type = redefine(FeatureTyping, "type", Type, Specialization.general)
FeatureTyping.owningFeature = redefine(FeatureTyping, "owningFeature", Feature, Specialization.owningType, opposite="ownedTyping")
FeatureTyping.typedFeature.add(FeatureTyping.owningFeature)  # type: ignore[attr-defined]
EndFeatureMembership.ownedMemberFeature = redefine(EndFeatureMembership, "ownedMemberFeature", Feature, FeatureMembership.ownedMemberFeature)
CrossSubsetting.crossedFeature = redefine(CrossSubsetting, "crossedFeature", Feature, Subsetting.subsettedFeature)
CrossSubsetting.crossingFeature = redefine(CrossSubsetting, "crossingFeature", Feature, Subsetting.owningFeature, opposite="ownedCrossSubsetting")
Dependency.client = redefine(Dependency, "client", Element, Relationship.source)
Dependency.supplier = redefine(Dependency, "supplier", Element, Relationship.target)
TextualRepresentation.representedElement = redefine(TextualRepresentation, "representedElement", Element, AnnotatingElement.annotatedElement, opposite="textualRepresentation")
Element.owner.add(TextualRepresentation.representedElement)  # type: ignore[attr-defined]
Documentation.documentedElement = redefine(Documentation, "documentedElement", Element, AnnotatingElement.annotatedElement, opposite="documentation")
Element.owner.add(Documentation.documentedElement)  # type: ignore[attr-defined]
Annotation.owningAnnotatedElement = derivedunion("owningAnnotatedElement", Element, upper=1)
Annotation.owningAnnotatingElement = derivedunion("owningAnnotatingElement", AnnotatingElement, upper=1)
Annotation.ownedAnnotatingElement = derivedunion("ownedAnnotatingElement", AnnotatingElement, upper=1)
Annotation.annotatingElement = redefine(Annotation, "annotatingElement", AnnotatingElement, Relationship.source, opposite="annotation")
Annotation.annotatedElement = redefine(Annotation, "annotatedElement", Element, Relationship.target)
Annotation.annotatedElement.add(Annotation.owningAnnotatedElement)  # type: ignore[attr-defined]
Relationship.owningRelatedElement.add(Annotation.owningAnnotatedElement)  # type: ignore[attr-defined]
Annotation.annotatingElement.add(Annotation.owningAnnotatingElement)  # type: ignore[attr-defined]
Relationship.owningRelatedElement.add(Annotation.owningAnnotatingElement)  # type: ignore[attr-defined]
Annotation.annotatingElement.add(Annotation.ownedAnnotatingElement)  # type: ignore[attr-defined]
Relationship.ownedRelatedElement.add(Annotation.ownedAnnotatingElement)  # type: ignore[attr-defined]
Import.importedElement = derivedunion("importedElement", Element, lower=1, upper=1)
Import.importOwningNamespace = redefine(Import, "importOwningNamespace", Namespace, Relationship.source, opposite="ownedImport")
Relationship.owningRelatedElement.add(Import.importOwningNamespace)  # type: ignore[attr-defined]
NamespaceImport.importedNamespace = redefine(NamespaceImport, "importedNamespace", Namespace, Relationship.target)
MembershipImport.importedMembership = redefine(MembershipImport, "importedMembership", Membership, Relationship.target)
