# This file is generated by coder.py. DO NOT EDIT!
# ruff: noqa: F401, E402, F811
# fmt: off

from __future__ import annotations

import enum

from gaphor.core.modeling.properties import (
    association,
    attribute as _attribute,
    derived,
    derivedunion,
    enumeration as _enumeration,
    redefine,
    relation_many,
    relation_one,
)



def _directed_relationship_property_path_target_source(type):
    return lambda self: [
        element.targetContext
        for element in self.model.select(type)
        if element.sourceContext is self and element.targetContext
    ]

from gaphor.UML.uml import NamedElement as _NamedElement
from gaphor.UML.uml import Class as _Class
from gaphor.UML.uml import DirectedRelationship as _DirectedRelationship
from gaphor.UML.uml import Dependency as _Dependency
from gaphor.UML.uml import Behavior as _Behavior
from gaphor.UML.uml import Property as _Property
from gaphor.UML.uml import DataType as _DataType
from gaphor.UML.uml import InstanceSpecification as _InstanceSpecification
from gaphor.UML.uml import Element as _Element
from gaphor.UML.uml import Connector as _Connector
from gaphor.UML.uml import ConnectorEnd as _ConnectorEnd
from gaphor.UML.uml import Classifier as _Classifier
from gaphor.UML.uml import Port as _Port
from gaphor.UML.uml import InvocationAction as _InvocationAction
from gaphor.UML.uml import Trigger as _Trigger
from gaphor.UML.uml import AddStructuralFeatureValueAction as _AddStructuralFeatureValueAction
from gaphor.UML.uml import ChangeEvent as _ChangeEvent
from gaphor.UML.uml import StructuralFeature as _StructuralFeature
from gaphor.UML.uml import AcceptEventAction as _AcceptEventAction
from gaphor.UML.uml import Feature as _Feature
from gaphor.UML.uml import Generalization as _Generalization
from gaphor.UML.uml import Comment as _Comment
from gaphor.UML.uml import Parameter as _Parameter
from gaphor.UML.uml import ActivityEdge as _ActivityEdge
from gaphor.UML.uml import ParameterSet as _ParameterSet
from gaphor.UML.uml import Operation as _Operation
from gaphor.UML.uml import ObjectNode as _ObjectNode
from gaphor.UML.uml import Abstraction as _Abstraction
from gaphor.UML.uml import ActivityPartition as _ActivityPartition
from gaphor.UML.uml import InformationFlow as _InformationFlow
from gaphor.UML.uml import Diagram as _Diagram


class FeatureDirectionKind(enum.StrEnum):
    provided = "provided"
    providedRequired = "providedRequired"
    required = "required"


class FlowDirectionKind(enum.StrEnum):
    in_ = "in"
    inout = "inout"
    out = "out"


class AbstractRequirement(_NamedElement):
    derived: derived[AbstractRequirement]
    derivedFrom: derived[AbstractRequirement]
    externalId: _attribute[str] = _attribute("externalId", str)
    master: derived[AbstractRequirement]
    refinedBy: derived[_NamedElement]
    satisfiedBy: derived[_NamedElement]
    text: _attribute[str] = _attribute("text", str)
    tracedTo: derived[_NamedElement]
    verifiedBy: derived[_NamedElement]


class Requirement(AbstractRequirement, _Class):
    pass


class DirectedRelationshipPropertyPath(_DirectedRelationship):
    sourceContext: relation_one[_Classifier]
    sourcePropertyPath: relation_many[_Property]
    targetContext: relation_one[_Classifier]
    targetPropertyPath: relation_many[_Property]


class Trace(DirectedRelationshipPropertyPath, _Dependency):
    pass


class Copy(Trace):
    pass


class Verify(Trace):
    pass


class DeriveReqt(Trace):
    pass


class Satisfy(Trace):
    pass


class TestCase(_Behavior):
    pass


class Block(_Class):
    isEncapsulated: _attribute[bool] = _attribute("isEncapsulated", bool, default=False)


class ConnectorProperty(_Property):
    connector: relation_one[_Connector]


class ParticipantProperty(_Property):
    end_: relation_one[_Property]


class DistributedProperty(_Property):
    pass


class ValueType(_DataType):
    quantityKind: relation_one[_InstanceSpecification]
    unit: relation_one[_InstanceSpecification]


class ElementPropertyPath(_Element):
    propertyPath: relation_many[_Property]


class BindingConnector(_Connector):
    pass


class NestedConnectorEnd(ElementPropertyPath, _ConnectorEnd):
    pass


class PropertySpecificType(_Classifier):
    pass


class EndPathMultiplicity(_Property):
    pass


class BoundReference(EndPathMultiplicity):
    bindingPath: relation_many[_Property]
    boundend: relation_many[_ConnectorEnd]


class AdjuntProperty(_Property):
    principal: relation_one[_Element]


class ProxyPort(_Port):
    pass


class FullPort(_Port):
    pass


class FlowProperty(_Property):
    direction = _enumeration("direction", FlowDirectionKind, FlowDirectionKind.inout)


class InterfaceBlock(Block):
    pass


class InvocationOnNestedPortAction(ElementPropertyPath, _InvocationAction):
    onNestedPort: relation_many[_Port]


class TriggerOnNestedPort(ElementPropertyPath, _Trigger):
    onNestedPort: relation_many[_Port]


class AddFlowPropertyValueOnNestedPortAction(ElementPropertyPath, _AddStructuralFeatureValueAction):
    pass


class ChangeSructuralFeatureEvent(_ChangeEvent):
    structuralFeature: relation_one[_StructuralFeature]


class AcceptChangeStructuralFeatureEventAction(_AcceptEventAction):
    pass


class DirectedFeature(_Feature):
    featureDirection = _enumeration("featureDirection", FeatureDirectionKind, FeatureDirectionKind.provided)


class Conform(_Generalization):
    pass


class View(_Class):
    stakeholder: relation_many[Stakeholder]
    viewpoint: relation_one[Viewpoint]


class Viewpoint(_Class):
    concernList: relation_many[_Comment]
    language: _attribute[str] = _attribute("language", str)
    method: relation_many[_Behavior]
    presentation: _attribute[str] = _attribute("presentation", str)
    purpose: _attribute[str] = _attribute("purpose", str)
    stakeholder: relation_many[Stakeholder]


class Stakeholder(_Classifier):
    concernList: relation_many[_Comment]


class Expose(_Dependency):
    pass


class Rationale(_Comment):
    pass


class Problem(_Comment):
    pass


class ElementGroup(_Comment):
    member: relation_many[_Element]
    name: _attribute[str] = _attribute("name", str)
    orderedMember: relation_many[_Element]


class ConstraintBlock(Block):
    pass


class Optional(_Parameter):
    pass


class Rate(_ActivityEdge, _Parameter):
    rate: relation_many[_InstanceSpecification]


class Probability(_ActivityEdge, _ParameterSet):
    probability: _attribute[str] = _attribute("probability", str)


class Continuous(Rate):
    pass


class Discrete(Rate):
    pass


class ControlOperator(_Behavior):
    pass


class NoBuffer(_ObjectNode):
    pass


class Overwrite(_ObjectNode):
    pass


class Allocate(DirectedRelationshipPropertyPath, _Abstraction):
    pass


class AllocateActivityPartition(_ActivityPartition):
    pass


class Refine(DirectedRelationshipPropertyPath, _Dependency):
    pass


class Tagged(_Property):
    nonunique: _attribute[bool] = _attribute("nonunique", bool)
    ordered: _attribute[bool] = _attribute("ordered", bool)
    subsets: _attribute[str] = _attribute("subsets", str)


class ClassifierBehaviorProperty(_Property):
    pass


class ItemFlow(_InformationFlow):
    itemProperty: relation_one[_Property]


class SysMLDiagram(_Diagram):
    pass


class StructureDiagram(SysMLDiagram):
    pass


class BehaviorDiagram(SysMLDiagram):
    pass


class BlockDefinitionDiagram(StructureDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="bdd")


class InternalBlockDiagram(StructureDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="ibd")


class ParametricDiagram(InternalBlockDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="par")


class PackageDiagram(StructureDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="pkg")


class RequirementDiagram(SysMLDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="req")


class ActivityDiagram(BehaviorDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="act")


class SequenceDiagram(BehaviorDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="sd")


class StateMachineDiagram(BehaviorDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="stm")


class UseCaseDiagram(BehaviorDiagram):
    diagramType: _attribute[str] = _attribute("diagramType", str, default="uc")



# 23: override AbstractRequirement.derived: derived[AbstractRequirement]

AbstractRequirement.derived = derived("derived", AbstractRequirement, 0, "*",
    _directed_relationship_property_path_target_source(DeriveReqt))

# 28: override AbstractRequirement.derivedFrom: derived[AbstractRequirement]

AbstractRequirement.derivedFrom = derived("derivedFrom", AbstractRequirement, 0, "*", lambda self: [
    element.sourceContext
    for element in self.model.select(DeriveReqt)
    if element.sourceContext and element.targetContext is self
])

# 36: override AbstractRequirement.master: derived[AbstractRequirement]

AbstractRequirement.master = derived("master", AbstractRequirement, 0, "*",
    _directed_relationship_property_path_target_source(Copy))

# 41: override AbstractRequirement.refinedBy: derived[_NamedElement]

AbstractRequirement.refinedBy = derived("refinedBy", _NamedElement, 0, "*",
    _directed_relationship_property_path_target_source(Refine))

# 46: override AbstractRequirement.satisfiedBy: derived[_NamedElement]

AbstractRequirement.satisfiedBy = derived("satisfiedBy", _NamedElement, 0, "*",
    _directed_relationship_property_path_target_source(Satisfy))

# 51: override AbstractRequirement.tracedTo: derived[_NamedElement]

AbstractRequirement.tracedTo = derived("tracedTo", _NamedElement, 0, "*",
    _directed_relationship_property_path_target_source(Trace))

# 56: override AbstractRequirement.verifiedBy: derived[_NamedElement]

AbstractRequirement.verifiedBy = derived("verifiedBy", _NamedElement, 0, "*",
    _directed_relationship_property_path_target_source(Verify))

DirectedRelationshipPropertyPath.sourcePropertyPath = association("sourcePropertyPath", _Property)
DirectedRelationshipPropertyPath.targetPropertyPath = association("targetPropertyPath", _Property)
DirectedRelationshipPropertyPath.targetContext = association("targetContext", _Classifier, upper=1, opposite="targetDirectedRelationshipPropertyPath_")
DirectedRelationshipPropertyPath.sourceContext = association("sourceContext", _Classifier, upper=1)
_Element.owner.add(DirectedRelationshipPropertyPath.targetContext)  # type: ignore[attr-defined]
_Property.itemFlow = association("itemFlow", ItemFlow, upper=1, opposite="itemProperty")
_Element.owner.add(_Property.itemFlow)  # type: ignore[attr-defined]
ConnectorProperty.connector = association("connector", _Connector, upper=1, composite=True)
ParticipantProperty.end_ = association("end_", _Property, upper=1, composite=True)
ValueType.unit = association("unit", _InstanceSpecification, upper=1)
ValueType.quantityKind = association("quantityKind", _InstanceSpecification, upper=1)
ElementPropertyPath.propertyPath = association("propertyPath", _Property, lower=1)
_Classifier.targetDirectedRelationshipPropertyPath_ = association("targetDirectedRelationshipPropertyPath_", DirectedRelationshipPropertyPath, composite=True, opposite="targetContext")
_Element.ownedElement.add(_Classifier.targetDirectedRelationshipPropertyPath_)  # type: ignore[attr-defined]
BoundReference.boundend = association("boundend", _ConnectorEnd, composite=True)
BoundReference.bindingPath = derivedunion("bindingPath", _Property, lower=1)
AdjuntProperty.principal = association("principal", _Element, upper=1)
InvocationOnNestedPortAction.onNestedPort = association("onNestedPort", _Port, lower=1)
TriggerOnNestedPort.onNestedPort = association("onNestedPort", _Port, lower=1)
ChangeSructuralFeatureEvent.structuralFeature = association("structuralFeature", _StructuralFeature, upper=1)
View.stakeholder = derivedunion("stakeholder", Stakeholder)
View.viewpoint = derivedunion("viewpoint", Viewpoint, upper=1)
Viewpoint.concernList = association("concernList", _Comment, composite=True)
Viewpoint.method = derivedunion("method", _Behavior)
Viewpoint.stakeholder = association("stakeholder", Stakeholder, composite=True)
Stakeholder.concernList = association("concernList", _Comment, composite=True)
ElementGroup.member = derivedunion("member", _Element)
ElementGroup.orderedMember = association("orderedMember", _Element, composite=True)
Rate.rate = association("rate", _InstanceSpecification, composite=True)
ItemFlow.itemProperty = association("itemProperty", _Property, upper=1, composite=True, opposite="itemFlow")
_Element.ownedElement.add(ItemFlow.itemProperty)  # type: ignore[attr-defined]
